<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/barcodemasters/favicon.ico" type="image/x-icon">
    <title>Barcode Masters - DNA Extractor</title>
    <link rel="stylesheet" href="assets/styles.css">
    <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    <style>
        footer {
            width: 100%;
            padding: 1rem;
            background: inherit;
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            position: static;
            bottom: 0;
            box-sizing: border-box;
        }
        .dna-extractor-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            box-sizing: border-box;
        }

        #interactive.viewport {
            position: relative;
            width: 100%;
            height: 300px;
            margin: 1rem 0;
        }

        #interactive.viewport > canvas, #interactive.viewport > video {
            max-width: 100%;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scan-button {
            padding: 1rem 2rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 1rem auto;
            border: none;
            display: block;
        }

        .scan-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .scan-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #statusMessages {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .monster-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .monster-image {
            width: 280px;  /* Fixed width */
            height: 280px; /* Fixed height - making it square */
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            text-align: center;
            margin: 1rem auto; /* Center the container */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monster-image img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changed from cover to contain */
            border-radius: 8px;
        }

        .monster-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .monster-stats p {
            margin: 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .navigation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .nav-button {
            padding: 1rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .nav-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #logoutButton {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
        }

        #logoutButton:hover {
            background: linear-gradient(135deg, #d35400, #e67e22);
        }

        body.dark-mode {
            background: #121212;
            color: white;
        }

        body.dark-mode .scan-button {
            background: linear-gradient(135deg, #2c3e50, #3498db);
        }

        body.dark-mode .scan-button:hover {
            background: linear-gradient(135deg, #34495e, #2980b9);
        }
    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">üåô</button>

    <div class="dna-extractor-container">
        <div class="logo-container">
            <img src="assets/images/BarcodeLogo1.PNG" alt="Barcode Masters Logo">
        </div>

        <h1>DNA Extractor</h1>
        
        <div id="statusMessages">
            <p id="errorMessage" style="color: red; display: none;"></p>
            <p id="debugMessage">Ready to scan...</p>
            <div id="scanFeedback" style="display: none; margin-top: 0.5rem;">
                <div class="scan-indicator" style="width: 100%; height: 4px; background: #ddd; border-radius: 2px;">
                    <div class="scan-progress" style="width: 0%; height: 100%; background: #3498db; border-radius: 2px; transition: width 0.3s ease;"></div>
                </div>
                <p class="scan-status" style="font-size: 0.8rem; margin-top: 0.5rem; text-align: center;">Scanning...</p>
            </div>
        </div>

        <div id="scanGuide" style="text-align: center; margin: 0.5rem 0; display: none;">
            <div style="background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 0.5rem; border-radius: 4px;">
                <p style="margin: 0; font-size: 0.9rem; display: flex; align-items: center; justify-content: space-around; gap: 0.5rem;">
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Hold Steady">üì±</span> Hold steady</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Center Code">üéØ</span> Center code</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Keep 6-8 inches away">üìè</span> 6-8" away</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Good Lighting">üí°</span> Good lighting</span>
                </p>
            </div>
        </div>
                      
        <div id="interactive" class="viewport" style="display: none;">
            <video id="video" autoplay playsinline muted></video>
        </div>

        <button class="scan-button" id="startButton">Start Scanner</button>
        <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">Not all codes will result in a successful scan. We are continuously working to add more code libraries to increase the number of scannable codes.</p>
        <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">QR codes are more likely to scan right now, barcode scanning is still somewhat limited.</p>    
        
        <!-- Add debug button -->
        <button class="scan-button" id="debugButton" style="display: none; background: linear-gradient(135deg, #8e44ad, #9b59b6);">
            Generate Test Monster
        </button>

        <div class="navigation-grid">
            <button class="nav-button" onclick="location.href='monster-collection.html'">Monster Collection</button>
            <button class="nav-button" onclick="location.href='train-monster.html'">Train Monster</button>
            <button class="nav-button" onclick="location.href='select-monster.html'">Battle Monsters</button>
            <button class="nav-button" onclick="location.href='profile.html'">Player Profile</button>     
            <button class="nav-button" onclick="location.href='monster-index.html'">Monster Index</button>
            <button class="nav-button" onclick="location.href='leaderboard.html'">Leaderboard</button>
            <button class="nav-button" onclick="location.href='help.html'">Help</button>
            <button class="nav-button" id="logoutButton">Logout</button>
        </div>

        <div id="monsterResult" style="display: none;"></div>
    </div>

    <footer>
        <p>Version: <span id="versionNumber">1.0.078</span></p>
        <p>&copy; 2025 Barcode Masters | <a href="/barcodemasters/changelog.html">Change Log</a> | <a href="/barcodemasters/privacy-policy.html">Privacy Policy</a></p> 
    </footer>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, runTransaction, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-storage.js";
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDoIWAIUt4HC1RcNmdfXozEr0NG65GO63s",
            authDomain: "barcodemasters-b4b9b.firebaseapp.com",
            projectId: "barcodemasters-b4b9b",
            storageBucket: "barcodemasters-b4b9b.firebasestorage.app",
            messagingSenderId: "827677074735",
            appId: "1:827677074735:web:3bace3d02034348bc82dda",
            measurementId: "G-14YTBBLTPZ"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const storage = getStorage(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Make db available globally
        window.db = db;

        // Constants are supposed to be pulling from the database check this !
        const MONSTER_TYPES = ['Feral', 'Fighter', 'Mage', 'Ranged', 'Tank'];
        const BASE_STAT_RANGES = {
            HP: { min: 3, max: 20 },    // Changed from {min: 5, max: 50}
            AP: { min: 1, max: 12 },    // Changed from {min: 1, max: 30}
            Speed: { min: 1, max: 8 }   // Changed from {min: 1, max: 20}
        };

        let codeReader = null;
        let selectedDeviceId = null;

        // Utility Functions
        function updateDebugMessage(message) {
            document.getElementById('debugMessage').textContent = message;
            console.log('Debug:', message);
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            console.error('Error:', message);
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function addDebugMessage(message) {
            const debugDiv = document.getElementById('debugMessage');
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `<br>[${timestamp}] ${message}`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        function resetUI() {
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('interactive').style.display = 'none';
        }

        function generateHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString().padStart(9, '0').slice(0, 9);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }
        // Scanner Functions
        async function initializeScanner() {
            try {
                updateDebugMessage('Initializing scanner...');
                hideError();
                document.getElementById('interactive').style.display = 'none';
                document.getElementById('startButton').style.display = 'block';

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    stream.getTracks().forEach(track => track.stop());
                } catch (permissionError) {
                    throw new Error('Camera permission denied. Please allow camera access and try again.');
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                if (videoDevices.length === 0) {
                    throw new Error('No camera found');
                }

                const backCamera = videoDevices.find(device => 
                    device.label.toLowerCase().includes('back') ||
                    device.label.toLowerCase().includes('rear')
                );
                
                selectedDeviceId = backCamera ? backCamera.deviceId : videoDevices[0].deviceId;
                
                if (codeReader) {
                    codeReader.reset();
                }
                codeReader = new ZXing.BrowserMultiFormatReader();
                
                updateDebugMessage('Scanner ready. Click "Start Scanner" to begin.');
            } catch (err) {
                console.error('Scanner initialization error:', err);
                showError(err.message);
                resetUI();
            }
        }

        function sanitizeCodeInput(rawInput) {
            try {
                let numbers = '';
                
                try {
                    const url = new URL(rawInput);
                    numbers = url.pathname.replace(/[^0-9]/g, '') || 
                             url.search.replace(/[^0-9]/g, '') ||
                             url.host.replace(/[^0-9]/g, '');
                } catch (e) {
                    numbers = rawInput.replace(/[^0-9]/g, '');
                }

                let hash = '';
                const input = numbers || rawInput;
                let total = 1;

                for (let i = 0; i < input.length; i++) {
                    total = (total * 31 + input.charCodeAt(i)) >>> 0;
                }

                const firstDigit = (total % 9) + 1;
                hash = firstDigit.toString();

                while (hash.length < 9) {
                    total = (total * 31) >>> 0;
                    hash += (total % 10).toString();
                }

                return hash;
            } catch (error) {
                console.error('Error sanitizing code input:', error);
                const timestamp = Date.now().toString();
                return ('1' + timestamp).slice(-9);
            }
        }

        async function startScanning() {
            const videoElement = document.getElementById('interactive');
            const scanFeedback = document.getElementById('scanFeedback');
            const scanGuide = document.getElementById('scanGuide');
            let scanAttempts = 0;
            let lastScanTime = 0;
            const SCAN_COOLDOWN = 1000; // 1 second between scan attempts
            
            try {
                hideError();
                document.getElementById('startButton').style.display = 'none';
                videoElement.style.display = 'block';
                scanFeedback.style.display = 'block';
                scanGuide.style.display = 'block';

                updateDebugMessage('Starting scanner...');

                // Check if user has scanned any codes before
                const user = auth.currentUser;
                if (!user) throw new Error('User not authenticated');
                
                const userRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userRef);
                const usedHashes = userDoc.data()?.usedHash || [];

                await codeReader.decodeFromVideoDevice(
                    selectedDeviceId,
                    'video',
                    async (result, err) => {
                        const now = Date.now();
                        if (result) {
                            if (now - lastScanTime < SCAN_COOLDOWN) {
                                return; // Ignore rapid successive scans
                            }
                            lastScanTime = now;

                            const sanitizedHash = sanitizeCodeInput(result.text);
                            
                            // Check for duplicate hash
                            if (usedHashes.includes(sanitizedHash)) {
                                updateDebugMessage('This code has already been scanned!');
                                showError('You have already extracted DNA from this code. Try a different one!');
                                // Don't stop scanner, let them try another code
                                return;
                            }

                            updateDebugMessage('Code found! Processing...');
                            stopScanning();
                            await generateMonster(sanitizedHash);
                        }
                        if (err && !(err instanceof ZXing.NotFoundException)) {
                            scanAttempts++;
                            const progress = Math.min((scanAttempts % 10) * 10, 100);
                            document.querySelector('.scan-progress').style.width = `${progress}%`;
                            
                            if (err.message.includes('no MultiFormat Readers')) {
                                showError('Scanner initialization failed. Please refresh the page.');
                                stopScanning();
                            }
                        }

                        // Update scanning feedback
                        const scanStatus = document.querySelector('.scan-status');
                        if (scanStatus) {
                            if (scanAttempts % 20 === 0) {
                                scanStatus.textContent = 'Still scanning... Try adjusting distance or angle';
                            } else if (scanAttempts % 30 === 0) {
                                scanStatus.textContent = 'Make sure the code is well-lit and centered';
                            }
                        }
                    }
                );

                updateDebugMessage('Scanner active - position a barcode or QR code in view');
            } catch (err) {
                console.error('Error starting scanner:', err);
                showError('Scanning failed: ' + err.message);
                resetUI();
            }
        }

        function stopScanning() {
            try {
                if (codeReader) {
                    codeReader.reset();
                }
                document.getElementById('scanFeedback').style.display = 'none';
                document.getElementById('scanGuide').style.display = 'none';
                resetUI();
            } catch (error) {
                console.error('Error stopping scanner:', error);
                resetUI();
            }
        }

        // Monster Generation Functions
        async function getMonsterTypes() {
            try {
                const monsterTypesCollection = collection(db, 'monsterTypes');
                const snapshot = await getDocs(monsterTypesCollection);
                
                const types = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    types.push({
                        typeName: data.typeName,
                        description: data.description,
                        statModifiers: {
                            HP: data.statModifiers.HP || 1,
                            AP: data.statModifiers.AP || 1,
                            Speed: data.statModifiers.Speed || 1
                        }
                    });
                });

                if (types.length === 0) {
                    throw new Error('No monster types found in database');
                }

                return types;
            } catch (error) {
                console.error('Error fetching monster types:', error);
                throw error;
            }
        }

        function generateName(seed) {
            // Your existing prefixes and suffixes arrays...
            const prefixes = ['Shadow', 'Crystal', 'Storm', 'Flame', 'Frost', 'Thunder', 'Mystic', 'Chaos', 'Cosmic', 'Dragon', 'Night', 'Star', 'Moon', 'Sun', 'Blood', 'Iron', 'Steel', 'Cyber', 'Quantum', 'Void', 'Terra', 'Pyro', 'Hydro', 'Aero', 'Geo', 'Necro', 'Tech', 'Pixel', 'Glitch', 'Neon'];
            const suffixes = ['fang', 'claw', 'wing', 'blade', 'heart', 'soul', 'strike', 'beam', 'pulse', 'wave', 'quake', 'storm', 'fury', 'rage', 'wrath', 'might', 'power', 'force'];
            
            const prefixIndex = Math.floor(seededRandom(seed) * prefixes.length);
            const suffixIndex = Math.floor(seededRandom(seed + 1) * suffixes.length);
            
            return `${prefixes[prefixIndex]}${suffixes[suffixIndex]}`;
        }

        function generateMonsterPrompt(monster, monsterTypes) {
            try {
                const typeInfo = monsterTypes.find(t => t.typeName === monster.type);
                if (!typeInfo) {
                    throw new Error('Monster type information not found');
                }

                // Create arrays for prompt parts
                let promptParts = [];
                const characteristics = [];
                
                // Enhanced positive prompt structure with stronger framing rules
                promptParts.push(
                    "character illustration",    
                    "award winning digital art",
                    "masterpiece",
                    "clean image",
                    "best quality",
                    "highly detailed",
                    `${monster.type.toLowerCase()} type creature`,
                    "complete full body shot",  // Changed
                    "entire creature visible",   // Added
                    "fits completely in frame",  // Added
                    "subject fully centered",    // Added
                    "symmetrical front view",    // Changed
                    "clear empty space around subject", // Added
                    "proper composition"         // Added
                );
                
                // Add type description
                if (typeInfo.description) {
                    promptParts.push(typeInfo.description);
                }
                
                // Add positive stat base characteristics
                if (monster.HP > 15) characteristics.push('massive, sturdy build');
                if (monster.AP > 8) characteristics.push('visible powerful features');
                if (monster.Speed > 5) characteristics.push('sleek, nimble, agile form');

                // Add negative stat based characteristics
                if (monster.HP < 5) characteristics.push('frail, weak build');
                if (monster.AP < 5) characteristics.push('scawny, weak features, no muscles');
                if (monster.Speed < 5) characteristics.push('heavy, slow, sluggish form');

                // Add characteristics if any exist
                if (characteristics.length > 0) {
                    promptParts.push(characteristics.join(', '));
                }

                promptParts.push(
                    `themed after ${monster.monsterName.toLowerCase()}`,
                    "dramatic lighting",
                    "vibrant colors",
                    "4k resolution"
                );

                // Combine into positive prompt
                const mainPrompt = promptParts.filter(Boolean).join(', ');

                // Enhanced negative prompts with stronger anti-text and anti-logo rules
                const negativePrompts = [
                    // Anti-cropping rules
                   // "(((cropped)))",
                   // "(((cropped limbs)))",
                   // "(((cropped body)))",
                   // "(((out of frame)))",
                   // "(((missing limbs)))",
                    
                    // Text and logo prevention (strengthened)
                    "text on image",
                   // "(((text)))",
                   // "(((words)))",
                   // "(((letters)))",
                   // "(((writing)))",
                   // "(((logo)))",
                   // "(((watermark)))",
                   // "(((signature)))",
                   // "(((copyright)))",
                   // "(((artist name)))",
                   // "(((brand mark)))",
                    
                    // Other existing rules
                    //"(((extra limbs)))",
                    //"((duplicate))",
                    //"((multiple views))",
                    //"((multiple creatures))",
                    //"((deformed))",
                    //"((amateur))",
                    //"((poorly drawn))",
                    //"((blurry))",
                    //"((bad anatomy))",
                    //"((bad proportions))",
                    //"((disfigured))",
                    //"((mutation))",
                    //"((humanoid))",
                    //"((human face))",
                    //"((human features))",
                    "wings on non winged creature",
                    //"frame",
                    //"border"
                ];

                // Debug output for verification
                console.group('Monster Prompt Debug');
                console.log('Monster Type:', monster.type);
                console.log('Base Stats:', {
                    HP: monster.HP,
                    AP: monster.AP,
                    Speed: monster.Speed
                });
                console.log('Characteristics:', characteristics);
                console.log('Final Positive Prompt:', mainPrompt);
                console.log('Negative Prompts:', negativePrompts.join(', '));
                console.groupEnd();

                return {
                    positivePrompt: mainPrompt,
                    negativePrompt: negativePrompts.join(', ')
                };
            } catch (error) {
                console.error('Error in generateMonsterPrompt:', error);
                return {
                    positivePrompt: 'high quality digital art of a fantasy creature character, full body, centered',
                    negativePrompt: '((cropped)), ((out of frame)), ((bad anatomy)), ((extra limbs))'
                };
            }
        }

        // Add this new function to verify image generation parameters
        function verifyImageGenerationParams(prompt, model) {
            console.group('Image Generation Parameters');
            console.log('Model:', model);
            console.log('Positive Prompt Length:', prompt.positivePrompt.length);
            console.log('Negative Prompt Length:', prompt.negativePrompt.length);
            console.log('Full Positive Prompt:', prompt.positivePrompt);
            console.log('Full Negative Prompt:', prompt.negativePrompt);
            console.groupEnd();

            // Add verification logic here
            if (prompt.positivePrompt.length < 10) {
                throw new Error('Positive prompt too short');
            }
            if (!prompt.positivePrompt.includes('full body')) {
                console.warn('Warning: Prompt missing full body specification');
            }
        }

        function calculateStat(statType, seed, statModifiers) {
            try {
                if (!BASE_STAT_RANGES[statType]) {
                    console.error('Invalid stat type:', statType);
                    return 0;
                }
                
                const range = BASE_STAT_RANGES[statType];
                const modifier = typeof statModifiers[statType] === 'number' ? statModifiers[statType] : 1;
                const randomValue = seededRandom(seed + Object.keys(BASE_STAT_RANGES).indexOf(statType));
                const baseStat = Math.floor(randomValue * (range.max - range.min) + range.min);
                const modifiedStat = Math.round(baseStat * modifier);
                
                return modifiedStat;
            } catch (error) {
                console.error('Error in calculateStat:', error);
                return BASE_STAT_RANGES[statType].min;
            }
        }

        async function generateMonster(hash) {
            try {
                const user = auth.currentUser;
                if (!user) {
                    throw new Error('User not authenticated');
                }

                const monsterTypes = await getMonsterTypes();
                console.log('Fetched monster types:', monsterTypes);

                if (!monsterTypes || monsterTypes.length === 0) {
                    throw new Error('No monster types available');
                }

                let seed;
                try {
                    const hashStr = generateHash(hash);
                    seed = parseInt(hashStr, 16);
                    if (isNaN(seed)) {
                        console.warn('Hash parsing failed, using fallback seed generation');
                        seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    }
                } catch (error) {
                    console.error('Error generating seed:', error);
                    seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                }

                const typeIndex = Math.floor(seededRandom(seed + 2) * monsterTypes.length);
                const selectedType = monsterTypes[typeIndex];

                if (!selectedType.statModifiers) {
                    throw new Error('Invalid monster type: missing stat modifiers');
                }

                const level = seededRandom(seed) < 0.2 ? 2 : 1;
                const monster = {
                    hash,
                    monsterName: generateName(seed),
                    type: selectedType.typeName,
                    level,
                    HP: calculateStat('HP', seed, selectedType.statModifiers),
                    AP: calculateStat('AP', seed, selectedType.statModifiers),
                    Speed: calculateStat('Speed', seed, selectedType.statModifiers),
                    experience: 0,
                    ownerId: user.uid,
                    dateCreated: new Date().toISOString(),
                    typeInfo: selectedType
                };

                if (level > 1) {
                    monster.HP = Math.round(monster.HP * (1 + (level - 1) * 0.2));     // Changed from 0.3
                    monster.AP = Math.round(monster.AP * (1 + (level - 1) * 0.15));    // Changed from 0.3
                    monster.Speed = Math.round(monster.Speed * (1 + (level - 1) * 0.1)); // Changed from 0.3
                }

                const monsterInstanceId = `${hash}-${user.uid}`;
                const monsterRef = doc(db, 'monsters', monsterInstanceId);
                await setDoc(monsterRef, monster);

                const userRef = doc(db, 'users', user.uid);
                await updateDoc(userRef, {
                    usedHash: arrayUnion(hash)
                });

                displayMonster(monster);
                updateDebugMessage('Monster generated successfully!');
                return monster;
            } catch (error) {
                console.error('Error generating monster:', error);
                showError(error.message || 'Failed to generate monster');
                return null;
            }
        }

        async function displayMonster(monster) {
            console.log('Displaying monster:', monster);
            const monsterResult = document.getElementById('monsterResult');
            if (!monsterResult) {
                console.error('Monster result element not found!');
                return;
            }

            try {
                // Generate prompt first before updating UI
                const prompt = generateMonsterPrompt(monster, [monster.typeInfo]);
                
                // Clear console and display prompt prominently
                console.clear();
                console.log('%c AI Image Generation Prompt:', 'color: #2ecc71; font-size: 14px; font-weight: bold;');
                console.log('%c' + prompt.positivePrompt, 'color: #3498db; font-size: 12px;');
                console.log('%c' + prompt.negativePrompt, 'color: #e74c3c; font-size: 12px;');
                console.log('%c' + '='.repeat(50), 'color: #95a5a6;');

                // Initial display with loading state
                monsterResult.style.display = 'block';
                monsterResult.innerHTML = `
                    <div class="monster-card">
                        <h2 style="text-align: center; margin-bottom: 1rem;">${monster.monsterName}</h2>
                        <div class="monster-image">
                            <div style="text-align: center;">
                                <p>Generating monster...</p>
                                <p style="font-size: 0.8em;">This process may take up to a few minutes.</p>
                                <p style="font-size: 0.8em;">Please remain on this page until the image appears</p>
                                <p style="font-size: 0.8em;">If one generation fails, click the button to try again</p>
                            </div>
                        </div>
                        <div class="monster-stats">
                            <p>Level: <span class="stat-value">...</span></p>
                            <p>Type: <span class="stat-value">...</span></p>
                            <p>HP: <span class="stat-value">...</span></p>
                            <p>AP: <span class="stat-value">...</span></p>
                            <p>Speed: <span class="stat-value">...</span></p>
                            <p>Hash ID: <span class="stat-value">...</span></p>
                        </div>
                    </div>
                `;

                updateDebugMessage('Generating image with custom prompt (check console for details)...');

                // Rest of the generation code
                const generateImage = async (retryCount = 0) => {
                    const timeout = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timeout')), 60000) // Increased timeout
                    );

                    const models = [
                        'Lykon/DreamShaper',
                        'prompthero/openjourney-v4',
                        'runwayml/stable-diffusion-v1-5',
                        'stabilityai/stable-diffusion-2-1'
                    ];

                    const modelIndex = retryCount % models.length;
                    const currentModel = models[modelIndex];
                    
                    // Exponential backoff with jitter
                    const baseDelay = 2000; // Start with 2 seconds
                    const maxDelay = 30000; // Max 30 seconds
                    const jitter = Math.random() * 1000;
                    const delay = Math.min(baseDelay * Math.pow(1.5, Math.floor(retryCount / 2)) + jitter, maxDelay);

                    try {
                        if (retryCount > 0) {
                            console.log(`Backing off for ${(delay/1000).toFixed(1)} seconds before retry ${retryCount}...`);
                            updateDebugMessage(`Cooling down... Next attempt in ${(delay/1000).toFixed(1)} seconds`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }

                        console.log(`Attempting model ${currentModel} (attempt ${retryCount + 1})`);
                        updateDebugMessage(`Generating with ${currentModel.split('/')[1]}...`);

                        const response = await Promise.race([
                            fetch(`https://api-inference.huggingface.co/models/${currentModel}`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': 'Bearer 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',
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    inputs: prompt.positivePrompt,
                                    parameters: {
                                        negative_prompt: prompt.negativePrompt,
                                        width: 512,
                                        height: 512,
                                        num_inference_steps: 30, // Increased for better quality
                                        guidance_scale: 8.5,     // Increased for stronger prompt adherence
                                        seed: Math.floor(Math.random() * 2147483647)
                                    }
                                })
                            }),
                            timeout
                        ]);

                        // Handle various response status codes
                        if (!response.ok) {
                            const errorBody = await response.text();
                            console.log(`Model response error: ${response.status} - ${errorBody}`);

                            if (response.status === 429 || response.status === 503) {
                                if (retryCount < models.length * 3) { // Try each model up to 3 times
                                    return generateImage(retryCount + 1);
                                }
                                throw new Error('All models are currently busy. Please try again later.');
                            }

                            throw new Error(`Model error: ${response.status}`);
                        }

                        const blob = await response.blob();
                        if (blob.size < 1000) {
                            throw new Error('Invalid image data received');
                        }

                        try {
                            // Use the new upload function
                            const imageUrl = await uploadMonsterImage(blob, monster);
                            return imageUrl;
                        } catch (storageError) {
                            console.error('Storage error:', storageError);
                            // Create temporary URL as fallback
                            const tempUrl = URL.createObjectURL(blob);
                            console.warn('Using temporary URL as fallback:', tempUrl);
                            return tempUrl;
                        }

                    } catch (error) {
                        console.error(`Attempt ${retryCount + 1} failed:`, error);
                        
                        if (retryCount < models.length * 3) {
                            console.log('Retrying with next model...');
                            return generateImage(retryCount + 1);
                        }
                        
                        // If all retries failed, throw final error
                        throw new Error('Unable to generate image after multiple attempts. Please try again later.');
                    }
                };

                const imageUrl = await generateImage();
                
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <img src="${imageUrl}" alt="${monster.monsterName}" 
                        style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                `;

                // Reveal stats with a slight delay after image loads
                setTimeout(() => {
                    const statValues = monsterResult.querySelectorAll('.stat-value');
                    const stats = [
                        monster.level,
                        monster.type,
                        monster.HP,
                        monster.AP,
                        monster.Speed,
                        monster.hash
                    ];
                    
                    stats.forEach((stat, index) => {
                        statValues[index].textContent = stat;
                        statValues[index].style.transition = 'opacity 0.5s';
                        statValues[index].style.opacity = '1';
                    });

                    // Add type description after stats are revealed
                    if (monster.typeInfo && monster.typeInfo.description) {
                        const typeDescription = document.createElement('p');
                        typeDescription.style.fontStyle = 'italic';
                        typeDescription.style.padding = '1rem';
                        typeDescription.style.margin = '0.5rem 0';
                        typeDescription.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                        typeDescription.style.borderRadius = '4px';
                        typeDescription.style.opacity = '0';
                        typeDescription.style.transition = 'opacity 0.5s';
                        typeDescription.textContent = monster.typeInfo.description;
                        monsterImage.insertAdjacentElement('afterend', typeDescription);
                        
                        // Trigger reflow before adding opacity
                        setTimeout(() => {
                            typeDescription.style.opacity = '1';
                        }, 100);
                    }
                }, 500); // Half second delay after image loads

            } catch (error) {
                console.error('Error generating image:', error);
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <p>Failed to generate image</p>
                        <p style="font-size: 0.8em; color: #666;">
                            ${error.message.includes('Rate limit') ? 
                            'Server is busy. Please wait a few minutes and try again.' : 
                            'An error occurred during image generation.'}
                        </p>
                        <button id="retryGenerationButton" class="scan-button" style="margin-top: 1rem;">
                            Try Again
                        </button>
                    </div>
                `;

                // Add click handler for retry button
                const retryButton = monsterImage.querySelector('#retryGenerationButton');
                retryButton.addEventListener('click', async () => {
                    // Remove the retry button and show loading state
                    monsterImage.innerHTML = `
                        <div style="text-align: center;">
                            <p>Regenerating monster image...</p>
                            <p style="font-size: 0.8em;">This process may take up to a few minutes.</p>
                            <p style="font-size: 0.8em;">We'll try multiple AI models to create the best possible image</p>
                            <p style="font-size: 0.8em;">Please remain on this page until the image appears</p>
                            <p style="font-size: 0.8em;">If one model fails, we'll automatically try others</p>
                        </div>
                    `;

                    try {
                        // Regenerate the image with the same prompt
                        const imageUrl = await generateImage();
                        monsterImage.innerHTML = `
                            <img src="${imageUrl}" alt="${monster.monsterName}" 
                                style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                        `;
                    } catch (retryError) {
                        // If retry fails, show the error message with retry button again
                        monsterImage.innerHTML = `
                            <div style="text-align: center; padding: 2rem;">
                                <p>Failed to generate image</p>
                                <p style="font-size: 0.8em; color: #666;">
                                    ${retryError.message.includes('Rate limit') ? 
                                    'Server is busy. Please wait a few minutes and try again.' : 
                                    'An error occurred during image generation.'}
                                </p>
                                <button id="retryGenerationButton" class="scan-button" style="margin-top: 1rem;">
                                    Try Again
                                </button>
                            </div>
                        `;
                        // Recursively add click handler to new retry button
                        monsterImage.querySelector('#retryGenerationButton').addEventListener('click', retryButton.onclick);
                    }
                });
            }
        }

        // Add this new function before generateImage
        async function uploadMonsterImage(blob, monster) {
            if (!blob || blob.size < 1000) {
                throw new Error('Invalid image data received');
            }

            try {
                // Create a unique ID for the monster image
                const monsterId = `${monster.hash}-${monster.ownerId}`;
                
                // Create storage reference
                const storageRef = ref(storage, `monster-images/${monsterId}.png`);
                
                // Create metadata
                const metadata = {
                    contentType: 'image/png',
                    customMetadata: {
                        monsterName: monster.monsterName,
                        monsterType: monster.type,
                        dateCreated: new Date().toISOString()
                    }
                };

                // Upload the blob with metadata
                const uploadResult = await uploadBytes(storageRef, blob, metadata);
                console.log('Image uploaded successfully:', uploadResult);

                // Get the download URL
                const imageUrl = await getDownloadURL(storageRef);
                console.log('Image URL generated:', imageUrl);

                // Update monster document with image URL
                const monsterRef = doc(db, 'monsters', monsterId);
                await updateDoc(monsterRef, { 
                    imageUrl: imageUrl,
                    lastUpdated: new Date().toISOString()
                });

                return imageUrl;
            } catch (error) {
                console.error('Error in uploadMonsterImage:', error);
                throw new Error(`Failed to upload image: ${error.message}`);
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initializeScanner();
            
            document.getElementById('startButton').addEventListener('click', startScanning);
            
            // Add debug button listener for instant monster generation
            document.getElementById('debugButton').addEventListener('click', async () => {
                const testHash = Math.floor(Math.random() * 900000000 + 100000000).toString();
                console.log('Generating test monster with hash:', testHash);
                await generateMonster(testHash);
            });
            
            document.getElementById('logoutButton').addEventListener('click', () => {
                auth.signOut().then(() => {
                    window.location.href = 'index.html';
                }).catch((error) => {
                    showError('Logout failed: ' + error.message);
                });
            });
        });

        // Auth check
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                window.location.href = 'index.html';
            } else {
                // Show debug button only for admin
                const debugButton = document.getElementById('debugButton');
                if (checkAdminStatus(user.uid)) {
                    debugButton.style.display = 'block';
                }
            }
        });

        // Add this function after Firebase initialization
        function checkAdminStatus(userId) {
            const adminId = 'Ngi2V2EdcFUeALSJjmY6XxfyxqL2';
            return userId === adminId;
        }

        // Dark mode toggle
        const darkModeToggle = document.getElementById("darkModeToggle");
        const savedTheme = localStorage.getItem("theme");

        if (savedTheme === "dark") {
            document.body.classList.add("dark-mode");
        }

        darkModeToggle.addEventListener("click", function() {
            document.body.classList.toggle("dark-mode");
            localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        });
    </script>
</body>
</html>
