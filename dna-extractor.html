<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/barcodemasters/favicon.ico" type="image/x-icon">
    <title>Barcode Masters - DNA Extractor</title>
    <link rel="stylesheet" href="assets/styles.css">
    <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    <style>
        footer {
            width: 100%;
            padding: 1rem;
            background: inherit;
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            position: static;
            bottom: 0;
            box-sizing: border-box;
        }
        .dna-extractor-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            box-sizing: border-box;
        }

        #interactive.viewport {
            position: relative;
            width: 100%;
            height: 300px;
            margin: 1rem 0;
        }

        #interactive.viewport > canvas, #interactive.viewport > video {
            max-width: 100%;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scan-button {
            padding: 1rem 2rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 1rem auto;
            border: none;
            display: block;
        }

        .scan-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .scan-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #statusMessages {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .monster-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .monster-image {
            background: rgba(0, 0, 0, 0.2);
            padding: 2rem;
            border-radius: 4px;
            text-align: center;
            margin: 1rem 0;
        }

        .monster-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .monster-stats p {
            margin: 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .navigation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .nav-button {
            padding: 1rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .nav-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #logoutButton {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
        }

        #logoutButton:hover {
            background: linear-gradient(135deg, #d35400, #e67e22);
        }

        body.dark-mode {
            background: #121212;
            color: white;
        }

        body.dark-mode .scan-button {
            background: linear-gradient(135deg, #2c3e50, #3498db);
        }

        body.dark-mode .scan-button:hover {
            background: linear-gradient(135deg, #34495e, #2980b9);
        }
    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">ðŸŒ™</button>

    <div class="dna-extractor-container">
        <div class="logo-container">
            <img src="assets/images/BarcodeLogo1.PNG" alt="Barcode Masters Logo">
        </div>

        <h1>DNA Extractor</h1>
        
        <div id="statusMessages">
            <p id="errorMessage" style="color: red; display: none;"></p>
            <p id="debugMessage">Ready to scan...</p>
        </div>
                      
        <div id="interactive" class="viewport" style="display: none;">
            <video id="video" autoplay playsinline muted></video>
        </div>

        <button class="scan-button" id="startButton">Start Scanner</button>
        <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">Not all codes will result in a successful scan. We are continuously working to add more code libraries to increase the number of scannable codes.</p>
        <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">QR codes are more likely to scan right now, barcode scanning is still somewhat limited.</p>    
        
        <div class="navigation-grid">
            <button class="nav-button" onclick="location.href='monster-collection.html'">Monster Collection</button>
            <button class="nav-button" onclick="location.href='train-monster.html'">Train Monster</button>
            <button class="nav-button" onclick="location.href='select-monster.html'">Battle Monsters</button>
            <button class="nav-button" onclick="location.href='profile.html'">Player Profile</button>     
            <button class="nav-button" onclick="location.href='monster-index.html'">Monster Index</button>
            <button class="nav-button" onclick="location.href='leaderboard.html'">Leaderboard</button>
            <button class="nav-button" onclick="location.href='help.html'">Help</button>
            <button class="nav-button" id="logoutButton">Logout</button>
        </div>

        <div id="monsterResult" style="display: none;"></div>
    </div>

    <footer>
        <p>Version: <span id="versionNumber">1.0.07</span></p>
        <p>&copy; 2025 Barcode Masters | <a href="/barcodemasters/changelog.html">Change Log</a> | <a href="/barcodemasters/privacy-policy.html">Privacy Policy</a></p> 
    </footer>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, runTransaction, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDoIWAIUt4HC1RcNmdfXozEr0NG65GO63s",
            authDomain: "barcodemasters-b4b9b.firebaseapp.com",
            projectId: "barcodemasters-b4b9b",
            storageBucket: "barcodemasters-b4b9b.firebasestorage.app",
            messagingSenderId: "827677074735",
            appId: "1:827677074735:web:3bace3d02034348bc82dda",
            measurementId: "G-14YTBBLTPZ"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Make db available globally
        window.db = db;

        // Constants
        const MONSTER_TYPES = ['Feral', 'Fighter', 'Mage', 'Ranged', 'Tank'];
        const BASE_STAT_RANGES = {
            HP: { min: 3, max: 20 },    // Changed from {min: 5, max: 50}
            AP: { min: 1, max: 12 },    // Changed from {min: 1, max: 30}
            Speed: { min: 1, max: 8 }   // Changed from {min: 1, max: 20}
        };

        let codeReader = null;
        let selectedDeviceId = null;

        // Utility Functions
        function updateDebugMessage(message) {
            document.getElementById('debugMessage').textContent = message;
            console.log('Debug:', message);
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            console.error('Error:', message);
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function addDebugMessage(message) {
            const debugDiv = document.getElementById('debugMessage');
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `<br>[${timestamp}] ${message}`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        function resetUI() {
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('interactive').style.display = 'none';
        }

        function generateHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString().padStart(9, '0').slice(0, 9);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }
        // Scanner Functions
        async function initializeScanner() {
            try {
                updateDebugMessage('Initializing scanner...');
                hideError();
                document.getElementById('interactive').style.display = 'none';
                document.getElementById('startButton').style.display = 'block';

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { facingMode: 'environment' } 
                    });
                    stream.getTracks().forEach(track => track.stop());
                } catch (permissionError) {
                    throw new Error('Camera permission denied. Please allow camera access and try again.');
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                if (videoDevices.length === 0) {
                    throw new Error('No camera found');
                }

                const backCamera = videoDevices.find(device => 
                    device.label.toLowerCase().includes('back') ||
                    device.label.toLowerCase().includes('rear')
                );
                
                selectedDeviceId = backCamera ? backCamera.deviceId : videoDevices[0].deviceId;
                
                if (codeReader) {
                    codeReader.reset();
                }
                codeReader = new ZXing.BrowserMultiFormatReader();
                
                updateDebugMessage('Scanner ready. Click "Start Scanner" to begin.');
            } catch (err) {
                console.error('Scanner initialization error:', err);
                showError(err.message);
                resetUI();
            }
        }

        function sanitizeCodeInput(rawInput) {
            try {
                let numbers = '';
                
                try {
                    const url = new URL(rawInput);
                    numbers = url.pathname.replace(/[^0-9]/g, '') || 
                             url.search.replace(/[^0-9]/g, '') ||
                             url.host.replace(/[^0-9]/g, '');
                } catch (e) {
                    numbers = rawInput.replace(/[^0-9]/g, '');
                }

                let hash = '';
                const input = numbers || rawInput;
                let total = 1;

                for (let i = 0; i < input.length; i++) {
                    total = (total * 31 + input.charCodeAt(i)) >>> 0;
                }

                const firstDigit = (total % 9) + 1;
                hash = firstDigit.toString();

                while (hash.length < 9) {
                    total = (total * 31) >>> 0;
                    hash += (total % 10).toString();
                }

                return hash;
            } catch (error) {
                console.error('Error sanitizing code input:', error);
                const timestamp = Date.now().toString();
                return ('1' + timestamp).slice(-9);
            }
        }

        async function startScanning() {
            const videoElement = document.getElementById('interactive');
            
            try {
                hideError();
                document.getElementById('startButton').style.display = 'none';
                videoElement.style.display = 'block';

                updateDebugMessage('Starting scanner...');

                await codeReader.decodeFromVideoDevice(
                    selectedDeviceId,
                    'video',
                    async (result, err) => {
                        if (result) {
                            updateDebugMessage('Code found!');
                            stopScanning();
                            const sanitizedHash = sanitizeCodeInput(result.text);
                            await generateMonster(sanitizedHash);
                        }
                        if (err && !(err instanceof ZXing.NotFoundException)) {
                            console.error('Scanning error:', err);
                        }
                    }
                );

                updateDebugMessage('Scanner active - point at a barcode or QR code');
            } catch (err) {
                console.error('Error starting scanner:', err);
                showError('Scanning failed: ' + err.message);
                resetUI();
            }
        }

        function stopScanning() {
            try {
                if (codeReader) {
                    codeReader.reset();
                }
                resetUI();
            } catch (error) {
                console.error('Error stopping scanner:', error);
                resetUI();
            }
        }

        // Monster Generation Functions
        async function getMonsterTypes() {
            try {
                const monsterTypesCollection = collection(db, 'monsterTypes');
                const snapshot = await getDocs(monsterTypesCollection);
                
                const types = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    types.push({
                        typeName: data.typeName,
                        description: data.description,
                        statModifiers: {
                            HP: data.statModifiers.HP || 1,
                            AP: data.statModifiers.AP || 1,
                            Speed: data.statModifiers.Speed || 1
                        }
                    });
                });

                if (types.length === 0) {
                    throw new Error('No monster types found in database');
                }

                return types;
            } catch (error) {
                console.error('Error fetching monster types:', error);
                throw error;
            }
        }

        function generateName(seed) {
            // Your existing prefixes and suffixes arrays...
            const prefixes = ['Shadow', 'Crystal', 'Storm', 'Flame', 'Frost', 'Thunder', 'Mystic', 'Chaos', 'Cosmic', 'Dragon', 'Night', 'Star', 'Moon', 'Sun', 'Blood', 'Iron', 'Steel', 'Cyber', 'Quantum', 'Void', 'Terra', 'Pyro', 'Hydro', 'Aero', 'Geo', 'Necro', 'Tech', 'Pixel', 'Glitch', 'Neon'];
            const suffixes = ['fang', 'claw', 'wing', 'blade', 'heart', 'soul', 'strike', 'beam', 'pulse', 'wave', 'quake', 'storm', 'fury', 'rage', 'wrath', 'might', 'power', 'force'];
            
            const prefixIndex = Math.floor(seededRandom(seed) * prefixes.length);
            const suffixIndex = Math.floor(seededRandom(seed + 1) * suffixes.length);
            
            return `${prefixes[prefixIndex]}${suffixes[suffixIndex]}`;
        }

        function generateMonsterPrompt(monster, monsterTypes) {
            const typeInfo = monsterTypes.find(t => t.typeName === monster.type);
            const typeDescription = typeInfo ? typeInfo.description : '';
            
            const statModifiers = [];
            if (monster.HP > 40) statModifiers.push('robust and powerful');
            if (monster.AP > 25) statModifiers.push('fierce looking');
            if (monster.Speed > 15) statModifiers.push('agile and sleek');
            
            const levelDetails = monster.level > 1 ? 'emanating strong power, enhanced appearance, ' : '';
            
            const basePrompt = `A ${monster.type.toLowerCase()} monster named ${monster.monsterName}, ${typeDescription}, ${statModifiers.join(', ')}, ${levelDetails}`;
            
            const styleModifiers = [
                'high quality digital art',
                'full body creature design',
                'centered view',
                'detailed fantasy game style',
                'on simple background',
                'professional game asset quality'
            ].join(', ');

            return `${basePrompt} ${styleModifiers}`;
        }
        function calculateStat(statType, seed, statModifiers) {
            try {
                if (!BASE_STAT_RANGES[statType]) {
                    console.error('Invalid stat type:', statType);
                    return 0;
                }
                
                const range = BASE_STAT_RANGES[statType];
                const modifier = typeof statModifiers[statType] === 'number' ? statModifiers[statType] : 1;
                const randomValue = seededRandom(seed + Object.keys(BASE_STAT_RANGES).indexOf(statType));
                const baseStat = Math.floor(randomValue * (range.max - range.min) + range.min);
                const modifiedStat = Math.round(baseStat * modifier);
                
                return modifiedStat;
            } catch (error) {
                console.error('Error in calculateStat:', error);
                return BASE_STAT_RANGES[statType].min;
            }
        }

        async function generateMonster(hash) {
            try {
                const user = auth.currentUser;
                if (!user) {
                    throw new Error('User not authenticated');
                }

                const monsterTypes = await getMonsterTypes();
                console.log('Fetched monster types:', monsterTypes);

                if (!monsterTypes || monsterTypes.length === 0) {
                    throw new Error('No monster types available');
                }

                let seed;
                try {
                    const hashStr = generateHash(hash);
                    seed = parseInt(hashStr, 16);
                    if (isNaN(seed)) {
                        console.warn('Hash parsing failed, using fallback seed generation');
                        seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    }
                } catch (error) {
                    console.error('Error generating seed:', error);
                    seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                }

                const typeIndex = Math.floor(seededRandom(seed + 2) * monsterTypes.length);
                const selectedType = monsterTypes[typeIndex];

                if (!selectedType.statModifiers) {
                    throw new Error('Invalid monster type: missing stat modifiers');
                }

                const level = seededRandom(seed) < 0.2 ? 2 : 1;
                const monster = {
                    hash,
                    monsterName: generateName(seed),
                    type: selectedType.typeName,
                    level,
                    HP: calculateStat('HP', seed, selectedType.statModifiers),
                    AP: calculateStat('AP', seed, selectedType.statModifiers),
                    Speed: calculateStat('Speed', seed, selectedType.statModifiers),
                    experience: 0,
                    ownerId: user.uid,
                    dateCreated: new Date().toISOString(),
                    typeInfo: selectedType
                };

                if (level > 1) {
                    monster.HP = Math.round(monster.HP * (1 + (level - 1) * 0.2));     // Changed from 0.3
                    monster.AP = Math.round(monster.AP * (1 + (level - 1) * 0.15));    // Changed from 0.3
                    monster.Speed = Math.round(monster.Speed * (1 + (level - 1) * 0.1)); // Changed from 0.3
                }

                const monsterInstanceId = `${hash}-${user.uid}`;
                const monsterRef = doc(db, 'monsters', monsterInstanceId);
                await setDoc(monsterRef, monster);

                const userRef = doc(db, 'users', user.uid);
                await updateDoc(userRef, {
                    usedHash: arrayUnion(hash)
                });

                displayMonster(monster);
                updateDebugMessage('Monster generated successfully!');
                return monster;
            } catch (error) {
                console.error('Error generating monster:', error);
                showError(error.message || 'Failed to generate monster');
                return null;
            }
        }

        async function displayMonster(monster) {
            console.log('Displaying monster:', monster);
            const monsterResult = document.getElementById('monsterResult');
            if (!monsterResult) {
                console.error('Monster result element not found!');
                return;
            }

            // Initial display with loading state
            monsterResult.style.display = 'block';
            monsterResult.innerHTML = `
                <div class="monster-card">
                    <h2 style="text-align: center; margin-bottom: 1rem;">${monster.monsterName}</h2>
                    <div class="monster-image">
                        <div style="text-align: center;">
                            <p>Generating monster image...</p>
                            <p style="font-size: 0.8em;">This may take up to 30 seconds</p>
                        </div>
                    </div>
                    <div class="monster-stats">
                        <p>Level: ${monster.level}</p>
                        <p>Type: ${monster.type}</p>
                        <p>HP: ${monster.HP}</p>
                        <p>AP: ${monster.AP}</p>
                        <p>Speed: ${monster.Speed}</p>
                        <p>Hash ID: ${monster.hash}</p>
                    </div>
                </div>
            `;

            try {
                const prompt = generateMonsterPrompt(monster, [monster.typeInfo]);
                console.log('Generated prompt:', prompt);

                // Function to attempt image generation with timeout
                const generateImage = async (retryCount = 0) => {
                    const timeout = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timeout')), 30000)
                    );

                    try {
                        const fetchPromise = fetch('https://api-inference.huggingface.co/models/stabilityai/stable-diffusion-2-1', {
                            method: 'POST',
                            headers: {
                                'Authorization': 'Bearer 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',
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                inputs: prompt,
                                negative_prompt: 'text, watermark, logo, blur, distortion, low quality, disfigured, human features, cartoon style',
                                parameters: {
                                    width: 512,
                                    height: 512,
                                    num_inference_steps: 30,  // Reduced steps for faster generation
                                    guidance_scale: 7.5
                                }
                            })
                        });

                        const response = await Promise.race([fetchPromise, timeout]);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const blob = await response.blob();
                        if (blob.size < 1000) {  // Check if the response is too small (likely an error)
                            throw new Error('Invalid image data received');
                        }

                        return URL.createObjectURL(blob);
                    } catch (error) {
                        if (retryCount < 2) {  // Retry up to 2 times
                            console.log(`Retry attempt ${retryCount + 1}`);
                            await new Promise(resolve => setTimeout(resolve, 2000));  // Wait 2s before retry
                            return generateImage(retryCount + 1);
                        }
                        throw error;
                    }
                };

                const imageUrl = await generateImage();
                
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <img src="${imageUrl}" alt="${monster.monsterName}" 
                        style="width: 100%; height: 200px; object-fit: cover; border-radius: 8px; display: block;">
                `;

                const monsterRef = doc(db, 'monsters', `${monster.hash}-${monster.ownerId}`);
                await updateDoc(monsterRef, {
                    imageUrl: imageUrl
                });

            } catch (error) {
                console.error('Error generating image:', error);
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <p>Failed to generate image</p>
                        <p style="font-size: 0.8em; color: #666;">
                            ${error.message === 'Request timeout' ? 
                            'Request timed out. Please try again with a better connection.' : 
                            'An error occurred during image generation.'}
                        </p>
                    </div>
                `;
            }
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', () => {
            initializeScanner();
            
            document.getElementById('startButton').addEventListener('click', startScanning);
            
            document.getElementById('logoutButton').addEventListener('click', () => {
                auth.signOut().then(() => {
                    window.location.href = 'index.html';
                }).catch((error) => {
                    showError('Logout failed: ' + error.message);
                });
            });
        });

        // Auth check
        onAuthStateChanged(auth, (user) => {
            if (!user) {
                window.location.href = 'index.html';
            }
        });

        // Dark mode toggle
        const darkModeToggle = document.getElementById("darkModeToggle");
        const savedTheme = localStorage.getItem("theme");

        if (savedTheme === "dark") {
            document.body.classList.add("dark-mode");
        }

        darkModeToggle.addEventListener("click", function() {
            document.body.classList.toggle("dark-mode");
            localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        });
    </script>
</body>
</html>
