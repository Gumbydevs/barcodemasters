<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/barcodemasters/favicon.ico" type="image/x-icon">
    <title>Barcode Masters - DNA Extractor</title>
    <link rel="stylesheet" href="assets/styles.css">
    <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>
    <style>
        footer {
            width: 100%;
            padding: 1rem;
            background: inherit;
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            position: static;
            bottom: 0;
            box-sizing: border-box;
        }
        .dna-extractor-container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 1rem;
            box-sizing: border-box;
        }

        #interactive.viewport {
            position: relative;
            width: 100%;
            height: 300px;
            margin: 1rem 0;
        }

        #interactive.viewport > canvas, #interactive.viewport > video {
            max-width: 100%;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scan-button {
            padding: 1rem 2rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 1rem auto;
            border: none;
            display: block;
        }

        .scan-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .scan-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #statusMessages {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
        }

        .monster-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .monster-image {
            width: 280px;  /* Fixed width */
            height: 280px; /* Fixed height - making it square */
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            text-align: center;
            margin: 1rem auto; /* Center the container */
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .monster-image img {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Changed from cover to contain */
            border-radius: 8px;
        }

        .monster-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .monster-stats p {
            margin: 0;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .navigation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .nav-button {
            padding: 1rem;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: none;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .nav-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        #logoutButton {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
        }

        #logoutButton:hover {
            background: linear-gradient(135deg, #d35400, #e67e22);
        }

        body.dark-mode {
            background: #121212;
            color: white;
        }

        body.dark-mode .scan-button {
            background: linear-gradient(135deg, #2c3e50, #3498db);
        }

        body.dark-mode .scan-button:hover {
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        .viewport-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .scanning-reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            border: 2px solid rgba(52, 152, 219, 0.8);
            border-radius: 20px;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
        }

        .scanning-reticle::before,
        .scanning-reticle::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            border-color: #3498db;
            border-style: solid;
        }

        .scanning-reticle::before {
            top: -2px;
            left: -2px;
            border-width: 2px 0 0 2px;
            border-radius: 20px 0 0 0;
        }

        .scanning-reticle::after {
            bottom: -2px;
            right: -2px;
            border-width: 0 2px 2px 0;
            border-radius: 0 0 20px 0;
        }

        .scanning-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: #3498db;
            animation: scan 2s linear infinite;
        }

        @keyframes scan {
            0% { top: 0; }
            50% { top: 100%; }
            100% { top: 0; }
        }

        .scan-limit-display {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.5rem;
            text-align: center;
            font-size: 0.9rem;
        }

        .scan-limit-count {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">üåô</button>

    <div class="dna-extractor-container">
        <div class="logo-container">
            <img src="assets/images/BarcodeLogo1.PNG" alt="Barcode Masters Logo">
        </div>

        <h1>DNA Extractor</h1>
        
        <button class="scan-button" id="startButton">Start DNA Code Scan</button>

        <div id="statusMessages">
            <p id="errorMessage" style="color: red; display: none;"></p>
            <p id="debugMessage">Ready to scan...</p>
            <div id="scanFeedback" style="display: none; margin-top: 0.5rem;">
                <div class="scan-indicator" style="width: 100%; height: 4px; background: #ddd; border-radius: 2px;">
                    <div class="scan-progress" style="width: 0%; height: 100%; background: #3498db; border-radius: 2px; transition: width 0.3s ease;"></div>
                </div>
                <p class="scan-status" style="font-size: 0.8rem; margin-top: 0.5rem; text-align: center;">Scanning...</p>
            </div>
        </div>

        <div id="scanLimitDisplay" class="scan-limit-display">
            Loading scan limit...
        </div>

        <div id="scanGuide" style="text-align: center; margin: 0.5rem 0; display: none;">
            <div style="background: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db; padding: 0.5rem; border-radius: 4px;">
                <p style="margin: 0; font-size: 0.9rem; display: flex; align-items: center; justify-content: space-around; gap: 0.5rem;">
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Center Code">üéØ</span> Center code</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Hold the camera and the code VERY Steady.">üì±</span> Hold steady</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Keep 6-8 inches away so the code is clearly in focus.">üìè</span>Keep 6-8" away</span>
                    <span style="display: flex; align-items: center; gap: 0.25rem;"><span title="Ensure that you have good Lighting">üí°</span> Ensure good lighting</span>
                </p>
            </div>
        </div>
                      
        <div id="monsterResult" style="display: none;"></div>

        <div id="interactive" class="viewport" style="display: none;">
            <video id="video" autoplay playsinline muted></video>
            <div class="viewport-overlay">
                <div class="scanning-reticle">
                    <div class="scanning-line"></div>
                </div>
            </div>
        </div>

        <div class="additional-info" style="margin-top: 1rem;">
            <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">Not all codes will result in a successful scan. We are continuously working to add more code libraries to increase the number of scannable codes.</p>
            <p style="text-align: center; font-size: 0.9rem; color: #555; margin-top: 0.5rem;">QR codes are more likely to scan right now, barcode scanning is still somewhat limited.</p>    
        </div>
        
        <!-- Add debug button -->
        <button class="scan-button" id="debugButton" style="display: none; background: linear-gradient(135deg, #8e44ad, #9b59b6);">
            Generate Test Monster
        </button>

        <div class="navigation-grid">
            <button class="nav-button" onclick="location.href='monster-collection.html'">Monster Collection</button>
            <button class="nav-button" onclick="location.href='train-monster.html'">Train Monster</button>
            <button class="nav-button" onclick="location.href='select-monster.html'">Battle Monsters</button>
            <button class="nav-button" onclick="location.href='profile.html'">Player Profile</button>     
            <button class="nav-button" onclick="location.href='monster-index.html'">Monster Index</button>
            <button class="nav-button" onclick="location.href='leaderboard.html'">Leaderboard</button>
            <button class="nav-button" onclick="location.href='help.html'">Help</button>
            <button class="nav-button" id="logoutButton">Logout</button>
        </div>
    </div>

    <footer>
        <p>Version: <span id="versionNumber">1.0.079</span></p>
        <p>&copy; 2025 Barcode Masters | <a href="/barcodemasters/changelog.html">Change Log</a> | <a href="/barcodemasters/privacy-policy.html">Privacy Policy</a></p> 
    </footer>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, arrayUnion, runTransaction, collection, getDocs } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-storage.js";
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDoIWAIUt4HC1RcNmdfXozEr0NG65GO63s",
            authDomain: "barcodemasters-b4b9b.firebaseapp.com",
            projectId: "barcodemasters-b4b9b",
            storageBucket: "barcodemasters-b4b9b.firebasestorage.app",
            messagingSenderId: "827677074735",
            appId: "1:827677074735:web:3bace3d02034348bc82dda",
            measurementId: "G-14YTBBLTPZ"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const storage = getStorage(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Make db available globally
        window.db = db;

        // Constants are supposed to be pulling from the database check this !
        const MONSTER_TYPES = ['Feral', 'Fighter', 'Mage', 'Ranged', 'Tank'];
        const BASE_STAT_RANGES = {
            HP: { min: 3, max: 20 },    // Changed from {min: 5, max: 50}
            AP: { min: 1, max: 12 },    // Changed from {min: 1, max: 30}
            Speed: { min: 1, max: 8 }   // Changed from {min: 1, max: 20}
        };

        let codeReader = null;
        let selectedDeviceId = null;

        // Utility Functions
        function updateDebugMessage(message) {
            document.getElementById('debugMessage').textContent = message;
            // Only log technical messages to console
            if (message.includes('Attempting model') || message.includes('error')) {
                console.log('Debug:', message);
            }
        }

        function showError(message) {
            const errorElement = document.getElementById('errorMessage');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            console.error('Error:', message);
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function addDebugMessage(message) {
            const debugDiv = document.getElementById('debugMessage');
            const timestamp = new Date().toLocaleTimeString();
            debugDiv.innerHTML += `<br>[${timestamp}] ${message}`;
            debugDiv.scrollTop = debugDiv.scrollHeight;
        }

        function resetUI() {
            document.getElementById('startButton').style.display = 'block';
            document.getElementById('interactive').style.display = 'none';
        }

        function generateHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash).toString().padStart(9, '0').slice(0, 9);
        }

        function seededRandom(seed) {
            const x = Math.sin(seed++) * 10000;
            return x - Math.floor(x);
        }

        function sanitizeCodeInput(code) {
            try {
                // Validate input
                if (!code || typeof code !== 'string') {
                    throw new Error('Invalid code input');
                }

                // Remove non-alphanumeric characters and whitespace
                let sanitized = code.replace(/[^a-zA-Z0-9]/g, '');
                
                // Check if we have any valid characters left
                if (!sanitized || sanitized.length < 1) {
                    throw new Error('No valid characters in code');
                }

                // Pad short codes by repeating the content
                if (sanitized.length < 8) {
                    let temp = sanitized;
                    while (sanitized.length < 8) {
                        sanitized += temp;
                    }
                }

                // Limit maximum length to 32 characters
                sanitized = sanitized.substring(0, 32);

                // Additional validation
                if (!/^[a-zA-Z0-9]+$/.test(sanitized)) {
                    throw new Error('Invalid characters detected after sanitization');
                }

                return sanitized;
            } catch (error) {
                console.error('Code sanitization error:', error);
                throw new Error(`Invalid code format: ${error.message}`);
            }
        }

        // Scanner Functions
        async function initializeScanner() {
            try {
                updateDebugMessage('Initializing scanner...');
                hideError();
                document.getElementById('interactive').style.display = 'none';
                document.getElementById('startButton').style.display = 'block';

                // Reset any existing scanner
                if (codeReader) {
                    codeReader.reset();
                }

                // Simple initialization - this was the key difference in the working version
                codeReader = new ZXing.BrowserMultiFormatReader();
                
                // Get cameras
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                if (videoDevices.length === 0) {
                    throw new Error('No camera found');
                }

                selectedDeviceId = videoDevices.find(device => 
                    device.label.toLowerCase().includes('back') ||
                    device.label.toLowerCase().includes('rear')
                )?.deviceId || videoDevices[0].deviceId;
                
                console.log('Scanner initialized with device:', selectedDeviceId);
                updateDebugMessage('Scanner ready. Click "Start Scanner" to begin.');
                return true;
            } catch (err) {
                console.error('Scanner initialization error:', err);
                showError(err.message);
                resetUI();
                return false;
            }
        }

        async function startScanning() {
            const videoElement = document.getElementById('interactive');
            
            try {
                hideError();
                document.getElementById('startButton').style.display = 'none';
                videoElement.style.display = 'block';
                document.getElementById('scanFeedback').style.display = 'block';
                document.getElementById('scanGuide').style.display = 'block';

                updateDebugMessage('Starting scanner...');

                await codeReader.decodeFromVideoDevice(
                    selectedDeviceId,
                    'video',
                    async (result, err) => {
                        if (result) {
                            updateDebugMessage('Code found!');
                            console.log('Scan result:', result);
                            try {
                                const sanitizedHash = sanitizeCodeInput(result.text);
                                stopScanning();
                                await generateMonster(sanitizedHash);
                            } catch (error) {
                                console.error('Error processing scan:', error);
                                showError(error.message);
                            }
                        }
                        if (err && !(err instanceof ZXing.NotFoundException)) {
                            console.error('Scanning error:', err);
                        }
                    }
                );

                updateDebugMessage('Scanner active - point at a barcode or QR code');
            } catch (err) {
                console.error('Error starting scanner:', err);
                showError('Scanning failed: ' + err.message);
                resetUI();
            }
        }

        function stopScanning() {
            try {
                if (codeReader) {
                    codeReader.reset();
                    const video = document.getElementById('video');
                    if (video && video.srcObject) {
                        video.srcObject.getTracks().forEach(track => track.stop());
                        video.srcObject = null;
                    }
                }
                document.getElementById('scanFeedback').style.display = 'none';
                document.getElementById('scanGuide').style.display = 'none';
                resetUI();
            } catch (error) {
                console.error('Error stopping scanner:', error);
                resetUI();
            }
        }

        // Monster Generation Functions
        async function getMonsterTypes() {
            try {
                const monsterTypesCollection = collection(db, 'monsterTypes');
                const snapshot = await getDocs(monsterTypesCollection);
                
                const types = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    types.push({
                        typeName: data.typeName,
                        description: data.description,
                        statModifiers: {
                            HP: data.statModifiers.HP || 1,
                            AP: data.statModifiers.AP || 1,
                            Speed: data.statModifiers.Speed || 1
                        }
                    });
                });

                if (types.length === 0) {
                    throw new Error('No monster types found in database');
                }

                return types;
            } catch (error) {
                console.error('Error fetching monster types:', error);
                throw error;
            }
        }

        function generateName(seed) {
            const prefixes = ['Shadow', 'Crystal', 'Storm', 'Flame', 'Frost', 'Thunder', 'Mystic', 'Chaos', 'Cosmic', 'Dragon', 'Night', 'Star', 'Moon', 'Sun', 'Blood', 'Iron', 'Steel', 'Cyber', 'Quantum', 'Void', 'Terra', 'Pyro', 'Hydro', 'Aero', 'Geo', 'Necro', 'Tech', 'Pixel', 'Glitch', 'Neon'];
            const suffixes = ['beast', 'walker', 'striker', 'hunter', 'claw', 'fang', 'wing', 'scale', 'spirit', 'soul', 'heart', 'blade', 'stalker', 'guard', 'sentinel', 'warden', 'keeper', 'slayer', 'bringer', 'weaver'];
            
            const prefixIndex = Math.floor(seededRandom(seed) * prefixes.length);
            const suffixIndex = Math.floor(seededRandom(seed + 1) * suffixes.length);
            
            return `${prefixes[prefixIndex]}${suffixes[suffixIndex]}`;
        }

        function generateMonsterPrompt(monster, typeInfo) {
            try {
                const promptParts = [];
                const characteristics = [];
                
                // Enhanced positive prompt structure with stronger framing rules
                promptParts.push(
                    "character illustration",    
                    "award winning digital art",
                    "masterpiece",
                    "clean image",
                    "best quality",
                    "highly detailed",
                    `${monster.type.toLowerCase()} type creature`,
                    "complete full body shot",
                    "entire creature visible",
                    "fits completely in frame",
                    "subject fully centered",
                    "symmetrical front view",
                    "clear empty space around subject",
                    "proper composition"
                );
                
                // Add type description
                if (typeInfo[0] && typeInfo[0].description) {
                    promptParts.push(typeInfo[0].description);
                }
                
                // Add stat-based characteristics
                if (monster.HP > 15) characteristics.push('massive, sturdy build');
                if (monster.AP > 8) characteristics.push('visible powerful features');
                if (monster.Speed > 5) characteristics.push('sleek, nimble, agile form');
                if (monster.HP < 5) characteristics.push('frail, weak build');
                if (monster.AP < 5) characteristics.push('scrawny, weak features');
                if (monster.Speed < 5) characteristics.push('heavy, slow form');

                if (characteristics.length > 0) {
                    promptParts.push(characteristics.join(', '));
                }

                promptParts.push(
                    `themed after ${monster.monsterName.toLowerCase()}`,
                    "dramatic lighting",
                    "vibrant colors",
                    "4k resolution"
                );

                return {
                    positivePrompt: promptParts.filter(Boolean).join(', '),
                    negativePrompt: "text, watermark, signature, cropped, bad anatomy, bad proportions, extra limbs, duplicate, deformed, mutation, blurry"
                };

            } catch (error) {
                console.error('Error in generateMonsterPrompt:', error);
                return {
                    positivePrompt: 'high quality digital art of a fantasy creature character, full body, centered',
                    negativePrompt: 'text, watermark, signature, cropped, bad anatomy, extra limbs'
                };
            }
        }

        function calculateStat(statType, seed, statModifiers) {
            try {
                if (!BASE_STAT_RANGES[statType]) {
                    console.error('Invalid stat type:', statType);
                    return 0;
                }
                
                const range = BASE_STAT_RANGES[statType];
                const modifier = typeof statModifiers[statType] === 'number' ? statModifiers[statType] : 1;
                const randomValue = seededRandom(seed + Object.keys(BASE_STAT_RANGES).indexOf(statType));
                const baseStat = Math.floor(randomValue * (range.max - range.min) + range.min);
                const modifiedStat = Math.round(baseStat * modifier);
                
                return modifiedStat;
            } catch (error) {
                console.error('Error in calculateStat:', error);
                return BASE_STAT_RANGES[statType].min;
            }
        }

        async function generateMonster(hash) {
            try {
                const user = auth.currentUser;
                if (!user) {
                    throw new Error('User not authenticated');
                }

                // Get user document
                const userRef = doc(db, 'users', user.uid);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    throw new Error('User profile not found');
                }

                const userData = userDoc.data();
                
                // Check for user's daily scan limit (default to 3 if not set)
                const dailyScanLimit = userData.dailyScanLimit || 3;

                // Check for duplicate hash
                if (userData.usedHash && userData.usedHash.includes(hash)) {
                    const monsterResult = document.getElementById('monsterResult');
                    monsterResult.style.display = 'block';
                    monsterResult.innerHTML = `
                        <div class="monster-card">
                            <div style="text-align: center; padding: 2rem;">
                                <h3 style="color: #e74c3c;">DNA Code Already Extracted</h3>
                                <p>This DNA code has already been synthesized by you.</p>
                                <p style="font-size: 0.9em; margin-top: 1rem;">Each unique DNA code can only be extracted once per player to maintain balance.</p>
                                <button class="scan-button" onclick="location.reload()" style="margin-top: 1rem;">
                                    Scan New Code
                                </button>
                                <button class="nav-button" onclick="location.href='monster-collection.html'" style="margin-top: 1rem;">
                                    View Your Collection
                                </button>
                            </div>
                        </div>
                    `;
                    updateDebugMessage('DNA code already used by this player');
                    return null;
                }

                // Check daily scan limit
                const today = new Date().toISOString().split('T')[0];
                const dailyScans = userData.dailyScans || {};
                const todayScans = dailyScans[today] || 0;

                if (todayScans >= dailyScanLimit) {
                    const monsterResult = document.getElementById('monsterResult');
                    monsterResult.style.display = 'block';
                    monsterResult.innerHTML = `
                        <div class="monster-card">
                            <div style="text-align: center; padding: 2rem;">
                                <h3 style="color: #e74c3c;">Daily DNA Extraction Limit Reached</h3>
                                <p>You have used ${todayScans} out of ${dailyScanLimit} DNA extractions for today.</p>
                                <p style="font-size: 0.9em; margin-top: 1rem;">Please wait until tomorrow to extract more DNA codes.</p>
                                <p style="font-size: 0.8em; color: #666;">Next reset: 12:00 AM your local time</p>
                                ${userData.accountType === 'free' ? `
                                    <p style="font-size: 0.8em; margin-top: 1rem;">
                                        <a href="upgrade-account.html" style="color: #3498db;">Upgrade your account</a>
                                        for additional daily DNA extractions!
                                    </p>
                                ` : ''}
                                <button class="nav-button" onclick="location.href='monster-collection.html'" style="margin-top: 1rem;">
                                    View Your Collection
                                </button>
                            </div>
                        </div>
                    `;
                    updateDebugMessage('Daily DNA extraction limit reached');
                    return null;
                }

                // Add remaining scans count to debug message
                updateDebugMessage(`DNA Extractor ready (${dailyScanLimit - todayScans} extractions remaining today)`);

                const monsterTypes = await getMonsterTypes();
                console.log('Fetched monster types:', monsterTypes);

                if (!monsterTypes || monsterTypes.length === 0) {
                    throw new Error('No monster types available');
                }

                let seed;
                try {
                    const hashStr = generateHash(hash);
                    seed = parseInt(hashStr, 16);
                    if (isNaN(seed)) {
                        console.warn('Hash parsing failed, using fallback seed generation');
                        seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    }
                } catch (error) {
                    console.error('Error generating seed:', error);
                    seed = Array.from(hash).reduce((acc, char) => acc + char.charCodeAt(0), 0);
                }

                const typeIndex = Math.floor(seededRandom(seed + 2) * monsterTypes.length);
                const selectedType = monsterTypes[typeIndex];

                if (!selectedType.statModifiers) {
                    throw new Error('Invalid monster type: missing stat modifiers');
                }

                const level = seededRandom(seed) < 0.2 ? 2 : 1;
                const monster = {
                    hash,
                    monsterName: generateName(seed),
                    type: selectedType.typeName,
                    level,
                    HP: calculateStat('HP', seed, selectedType.statModifiers),
                    AP: calculateStat('AP', seed, selectedType.statModifiers),
                    Speed: calculateStat('Speed', seed, selectedType.statModifiers),
                    experience: 0,
                    ownerId: user.uid,
                    dateCreated: new Date().toISOString(),
                    typeInfo: selectedType,
                    createdBy: userData.username || 'Unknown Player'
                };

                if (level > 1) {
                    monster.HP = Math.round(monster.HP * (1 + (level - 1) * 0.2));     // Changed from 0.3
                    monster.AP = Math.round(monster.AP * (1 + (level - 1) * 0.15));    // Changed from 0.3
                    monster.Speed = Math.round(monster.Speed * (1 + (level - 1) * 0.1)); // Changed from 0.3
                }

                const monsterInstanceId = `${hash}-${user.uid}`;
                const monsterRef = doc(db, 'monsters', monsterInstanceId);
                await setDoc(monsterRef, monster);

                // Update user's daily scans and used hash in a transaction
                await runTransaction(db, async (transaction) => {
                    const userDocRef = doc(db, 'users', user.uid);
                    const userSnapshot = await transaction.get(userDocRef);
                    
                    if (!userSnapshot.exists()) {
                        throw new Error('User document does not exist!');
                    }

                    const userData = userSnapshot.data();
                    const newDailyScans = { ...userData.dailyScans } || {};
                    newDailyScans[today] = (newDailyScans[today] || 0) + 1;

                    transaction.update(userDocRef, {
                        usedHash: arrayUnion(hash),
                        dailyScans: newDailyScans
                    });
                });

                // After successful monster generation, update the display
                updateScanLimitDisplay(userData.dailyScans || {}, dailyScanLimit);

                displayMonster(monster);
                updateDebugMessage('Monster DNA sequence found! Beginning synthesis...');
                return monster;

            } catch (error) {
                console.error('Error generating monster:', error);
                showError(error.message || 'Failed to generate monster');
                return null;
            }
        }

        async function displayMonster(monster) {
            console.log('Displaying monster:', monster);
            const monsterResult = document.getElementById('monsterResult');
            if (!monsterResult) {
                console.error('Monster result element not found!');
                return;
            }

            try {
                // Generate prompt first before updating UI
                const prompt = generateMonsterPrompt(monster, [monster.typeInfo]);
                
                // Clear console and display prompt prominently
                console.clear();
                console.log('%c AI Image Generation Prompt:', 'color: #2ecc71; font-size: 14px; font-weight: bold;');
                console.log('%c' + prompt.positivePrompt, 'color: #3498db; font-size: 12px;');
                console.log('%c' + prompt.negativePrompt, 'color: #e74c3c; font-size: 12px;');
                console.log('%c' + '='.repeat(50), 'color: #95a5a6;');

                // Initial display with loading state
                monsterResult.style.display = 'block';
                monsterResult.innerHTML = `
                    <div class="monster-card">
                        <h2 style="text-align: center; margin-bottom: 1rem;">${monster.monsterName}</h2>
                        <div class="monster-image">
                            <div style="text-align: center;">
                                <p>Synthesizing Monster DNA...</p>
                                <p style="font-size: 0.8em;">This process can take up to a few minutes...</p>
                                <p style="font-size: 0.8em;">Stay on this page until your monster is displayed...</p>
                                <p style="font-size: 0.8em;">Getting ready to materialize...</p>
                            </div>
                        </div>
                        <div class="monster-stats">
                            <p>Level: <span class="stat-value">...</span></p>
                            <p>Type: <span class="stat-value">...</span></p>
                            <p>HP: <span class="stat-value">...</span></p>
                            <p>AP: <span class="stat-value">...</span></p>
                            <p>Speed: <span class="stat-value">...</span></p>
                            <p>Hash ID: <span class="stat-value">...</span></p>
                        </div>
                    </div>
                `;

                updateDebugMessage('Materializing your monster...');

                // Rest of the generation code
                const generateImage = async (retryCount = 0) => {
                    const timeout = new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Request timeout')), 60000) // Increased timeout
                    );

                    const models = [
                        'Lykon/DreamShaper',
                        'prompthero/openjourney-v4',
                        'runwayml/stable-diffusion-v1-5',
                        //'stabilityai/stable-diffusion-2-1'
                    ];

                    const modelIndex = retryCount % models.length;
                    const currentModel = models[modelIndex];
                    
                    // Exponential backoff with jitter
                    const baseDelay = 2000; // Start with 2 seconds
                    const maxDelay = 30000; // Max 30 seconds
                    const jitter = Math.random() * 1000;
                    const delay = Math.min(baseDelay * Math.pow(1.5, Math.floor(retryCount / 2)) + jitter, maxDelay);

                    try {
                        if (retryCount > 0) {
                            console.log(`DNA Extractor overheating, backing off for ${(delay/1000).toFixed(1)} seconds before retry ${retryCount}...`);
                            updateDebugMessage(`Cooling down... Next attempt in ${(delay/1000).toFixed(1)} seconds`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }

                        console.log(`Attempting to synthesize appearence with model ${currentModel} (attempt ${retryCount + 1})`);
                        updateDebugMessage(`Synthesizing appearence with ${currentModel.split('/')[1]}...`);

                        const response = await Promise.race([
                            fetch(`https://api-inference.huggingface.co/models/${currentModel}`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': 'Bearer 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',
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    inputs: prompt.positivePrompt,
                                    parameters: {
                                        negative_prompt: prompt.negativePrompt,
                                        width: 512,
                                        height: 512,
                                        num_inference_steps: 30, // Increased for better quality
                                        guidance_scale: 8.5,     // Increased for stronger prompt adherence
                                        seed: Math.floor(Math.random() * 2147483647)
                                    }
                                })
                            }),
                            timeout
                        ]);

                        // Handle various response status codes
                        if (!response.ok) {
                            const errorBody = await response.text();
                            console.log(`Model response error: ${response.status} - ${errorBody}`);

                            if (response.status === 429 || response.status === 503) {
                                if (retryCount < models.length * 3) { // Try each model up to 3 times
                                    return generateImage(retryCount + 1);
                                }
                                throw new Error('All models are currently busy. Please try again later.');
                            }

                            throw new Error(`Model error: ${response.status}`);
                        }

                        const blob = await response.blob();
                        if (blob.size < 1000) {
                            throw new Error('Invalid image data received');
                        }

                        try {
                            // Use the new upload function
                            const imageUrl = await uploadMonsterImage(blob, monster);
                            return imageUrl;
                        } catch (storageError) {
                            console.error('Storage error:', storageError);
                            // Create temporary URL as fallback
                            const tempUrl = URL.createObjectURL(blob);
                            console.warn('Using temporary URL as fallback:', tempUrl);
                            return tempUrl;
                        }

                    } catch (error) {
                        console.error(`Attempt ${retryCount + 1} failed:`, error);
                        
                        if (retryCount < models.length * 3) {
                            console.log('Retrying with next model...');
                            return generateImage(retryCount + 1);
                        }
                        
                        // If all retries failed, throw final error
                        throw new Error('Unable to generate image after multiple attempts. Please try again later.');
                    }
                };

                const imageUrl = await generateImage();
                
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <img src="${imageUrl}" alt="${monster.monsterName}" 
                        style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                `;

                // Reveal stats with a slight delay after image loads
                setTimeout(() => {
                    const statValues = monsterResult.querySelectorAll('.stat-value');
                    const stats = [
                        monster.level,
                        monster.type,
                        monster.HP,
                        monster.AP,
                        monster.Speed,
                        monster.hash
                    ];
                    
                    stats.forEach((stat, index) => {
                        statValues[index].textContent = stat;
                        statValues[index].style.transition = 'opacity 0.5s';
                        statValues[index].style.opacity = '1';
                    });

                    // Add type description after stats are revealed
                    if (monster.typeInfo && monster.typeInfo.description) {
                        const typeDescription = document.createElement('p');
                        typeDescription.style.fontStyle = 'italic';
                        typeDescription.style.padding = '1rem';
                        typeDescription.style.margin = '0.5rem 0';
                        typeDescription.style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
                        typeDescription.style.borderRadius = '4px';
                        typeDescription.style.opacity = '0';
                        typeDescription.style.transition = 'opacity 0.5s';
                        typeDescription.textContent = monster.typeInfo.description;
                        monsterImage.insertAdjacentElement('afterend', typeDescription);
                        
                        // Trigger reflow before adding opacity
                        setTimeout(() => {
                            typeDescription.style.opacity = '1';
                        }, 100);
                    }
                }, 500); // Half second delay after image loads

            } catch (error) {
                console.error('Error generating image:', error);
                const monsterImage = monsterResult.querySelector('.monster-image');
                monsterImage.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <p>DNA Synthesis Interrupted</p>
                        <p style="font-size: 0.8em; color: #666;">
                            ${error.message.includes('Rate limit') ? 
                            'The DNA Synthesizer needs time to recharge. Please wait a moment...' : 
                            'A DNA sequencing error occurred. Please try again.'}
                        </p>
                        <button id="retryGenerationButton" class="scan-button" style="margin-top: 1rem;">
                            Retry DNA Synthesis
                        </button>
                    </div>
                `;

                // Add click handler for retry button
                const retryButton = monsterImage.querySelector('#retryGenerationButton');
                retryButton.addEventListener('click', async () => {
                    // Remove the retry button and show loading state
                    monsterImage.innerHTML = `
                        <div style="text-align: center;">
                            <p>Recalibrating DNA Synthesis...</p>
                            <p style="font-size: 0.8em;">Adjusting genetic parameters...</p>
                            <p style="font-size: 0.8em;">Stabilizing molecular structure...</p>
                            <p style="font-size: 0.8em;">Stand by for materialization...</p>
                        </div>
                    `;

                    try {
                        // Regenerate the image with the same prompt
                        const imageUrl = await generateImage();
                        monsterImage.innerHTML = `
                            <img src="${imageUrl}" alt="${monster.monsterName}" 
                                style="width: 100%; height: 100%; object-fit: contain; border-radius: 8px;">
                        `;
                    } catch (retryError) {
                        // If retry fails, show the error message with retry button again
                        monsterImage.innerHTML = `
                            <div style="text-align: center; padding: 2rem;">
                                <p>DNA Synthesis Interrupted</p>
                                <p style="font-size: 0.8em; color: #666;">
                                    ${retryError.message.includes('Rate limit') ? 
                                    'The DNA Synthesizer needs time to recharge. Please wait a moment...' : 
                                    'A DNA sequencing error occurred. Please try again.'}
                                </p>
                                <button id="retryGenerationButton" class="scan-button" style="margin-top: 1rem;">
                                    Retry DNA Synthesis
                                </button>
                            </div>
                        `;
                        // Recursively add click handler to new retry button
                        monsterImage.querySelector('#retryGenerationButton').addEventListener('click', retryButton.onclick);
                    }
                });
            }
        }

        // Add this new function before generateImage
        async function uploadMonsterImage(blob, monster) {
            if (!blob || blob.size < 1000) {
                throw new Error('Invalid image data received');
            }

            try {
                // Create a unique ID for the monster image
                const monsterId = `${monster.hash}-${monster.ownerId}`;
                
                // Create storage reference
                const storageRef = ref(storage, `monster-images/${monsterId}.png`);
                
                // Create metadata
                const metadata = {
                    contentType: 'image/png',
                    customMetadata: {
                        monsterName: monster.monsterName,
                        monsterType: monster.type,
                        dateCreated: new Date().toISOString()
                    }
                };

                // Upload the blob with metadata
                const uploadResult = await uploadBytes(storageRef, blob, metadata);
                console.log('Image uploaded successfully:', uploadResult);

                // Get the download URL
                const imageUrl = await getDownloadURL(storageRef);
                console.log('Image URL generated:', imageUrl);

                // Update monster document with image URL
                const monsterRef = doc(db, 'monsters', monsterId);
                await updateDoc(monsterRef, { 
                    imageUrl: imageUrl,
                    lastUpdated: new Date().toISOString()
                });

                return imageUrl;
            } catch (error) {
                console.error('Error in uploadMonsterImage:', error);
                throw new Error(`Failed to upload image: ${error.message}`);
            }
        }

        // Add this new function to initialize/update user fields
        async function ensureUserFields(userId) {
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                
                if (!userDoc.exists()) {
                    throw new Error('User document not found');
                }

                const userData = userDoc.data();
                const updates = {};
                
                // Default values for required fields
                if (!userData.dailyScanLimit) updates.dailyScanLimit = 3;
                if (!userData.dailyScans) updates.dailyScans = {};
                if (!userData.usedHash) updates.usedHash = [];
                if (!userData.accountType) updates.accountType = 'free';
                
                // Only update if there are missing fields
                if (Object.keys(updates).length > 0) {
                    await updateDoc(userRef, updates);
                    console.log('User fields initialized:', updates);
                }

                return { ...userData, ...updates };
            } catch (error) {
                console.error('Error initializing user fields:', error);
                throw error;
            }
        }

        // Add this function to update the scan limit display
        function updateScanLimitDisplay(dailyScans, dailyScanLimit) {
            const display = document.getElementById('scanLimitDisplay');
            if (!display) return;

            const today = new Date().toISOString().split('T')[0];
            const usedToday = dailyScans[today] || 0;
            const remaining = dailyScanLimit - usedToday;

            display.innerHTML = `
                <span class="scan-limit-count">${remaining}</span> DNA extractions remaining today
                <br>
                <small>(${usedToday}/${dailyScanLimit} used)</small>
            `;
        }

        // Event Listeners
        document.addEventListener('DOMContentLoaded', async () => {
            initializeScanner();
            
            const user = auth.currentUser;
            if (user) {
                try {
                    // Initialize user fields and get updated data
                    const userData = await ensureUserFields(user.uid);
                    
                    // Update display with user's scan limits
                    const today = new Date().toISOString().split('T')[0];
                    updateScanLimitDisplay(userData.dailyScans || {}, userData.dailyScanLimit || 3);
                    
                    updateDebugMessage('DNA Extractor ready');
                } catch (error) {
                    console.error('Error initializing user data:', error);
                    showError('Error loading user data');
                }
            }
            
            document.getElementById('startButton').addEventListener('click', startScanning);
            
            // Add debug button listener for instant monster generation
            document.getElementById('debugButton').addEventListener('click', async () => {
                const testHash = Math.floor(Math.random() * 900000000 + 100000000).toString();
                console.log('Generating test monster with hash:', testHash);
                await generateMonster(testHash);
            });
            
            document.getElementById('logoutButton').addEventListener('click', () => {
                auth.signOut().then(() => {
                    window.location.href = 'index.html';
                }).catch((error) => {
                    showError('Logout failed: ' + error.message);
                });
            });
        });

        // Auth check
        onAuthStateChanged(auth, async (user) => {
            if (!user) {
                window.location.href = 'index.html';
            } else {
                try {
                    // Initialize user fields on auth state change
                    const userData = await ensureUserFields(user.uid);
                    updateScanLimitDisplay(userData.dailyScans || {}, userData.dailyScanLimit || 3);
                    
                    // Show debug button only for admin
                    const debugButton = document.getElementById('debugButton');
                    if (checkAdminStatus(user.uid)) {
                        debugButton.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error initializing user data:', error);
                    showError('Error loading user data');
                }
            }
        });

        // Add this function after Firebase initialization
        function checkAdminStatus(userId) {
            const adminId = 'Ngi2V2EdcFUeALSJjmY6XxfyxqL2';
            return userId === adminId;
        }

        // Dark mode toggle
        const darkModeToggle = document.getElementById("darkModeToggle");
        const savedTheme = localStorage.getItem("theme");

        if (savedTheme === "dark") {
            document.body.classList.add("dark-mode");
        }

        darkModeToggle.addEventListener("click", function() {
            document.body.classList.toggle("dark-mode");
            localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        });

        // Update dark mode styles
        const darkModeStyles = `
            body.dark-mode {
                background: #121212;
                color: #ffffff;
            }
            
            body.dark-mode .monster-card {
                background: rgba(255, 255, 255, 0.1);
            }
            
            body.dark-mode .scan-button {
                background: linear-gradient(135deg, #2c3e50, #3498db);
            }
            
            body.dark-mode .scan-button:hover {
                background: linear-gradient(135deg, #34495e, #2980b9);
            }
            
            body.dark-mode #statusMessages {
                background: rgba(255, 255, 255, 0.05);
            }
        `;

        // Add dark mode styles to document
        const styleSheet = document.createElement("style");
        styleSheet.textContent = darkModeStyles;
        document.head.appendChild(styleSheet);
    </script>
</body>
</html>
