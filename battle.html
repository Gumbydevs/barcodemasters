<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Barcode Masters - Battle System</title>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-storage-compat.js"></script>
    <style>
        /* Collection-style layout */
        body { 
            font-family: Arial, sans-serif; 
            background-color: #f3f4f6; 
            color: #070707; /* Default text color for light mode */
            margin: 0; 
            padding: 0; 
            min-height: 100vh; 
        }
        
        body.dark-mode {
            background: #121212 !important;  /* Updated from any previous color to match monster-collection */
            color: #ffffff; /* Text color for dark mode */
        }

        .battle-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            padding-top: 6rem;
            box-sizing: border-box;
            color: inherit; /* Inherit text color from body */
            background: rgba(12, 12, 12, 0.1);
            border-radius: 12px;
        }

        body.dark-mode .battle-container {
            background: rgba(14, 13, 13, 0.7) !important; /* Darker background for dark mode */
        }

        @media (max-width: 768px) {
            .battle-container {
                background: rgba(255, 255, 255, 0.9); /* Lighter background for light mode on mobile */
                padding: 1rem;
                padding-top: 4rem;
            }

            body.dark-mode .battle-container {
                background: rgba(30, 41, 59, 0.95); /* Darker and more opaque for dark mode on mobile */
            }

            .battle-log {
                background: rgba(0, 0, 0, 0.15); /* Slightly darker for better contrast on mobile */
            }

            body.dark-mode .battle-log {
                background: rgba(0, 0, 0, 0.3); /* Even darker in dark mode for better contrast */
            }
        }

        /* Monster card styling */
        .monster-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .monster-card {
            background: rgba(255, 255, 255, 0.05);
        }

        .monster-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        /* Navigation grid */
        .navigation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .nav-button {
            padding: 1rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        /* Footer */
        footer {
            width: 100%;
            padding: 1rem;
            background: inherit;
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            margin-top: 2rem;
            color: inherit; /* Inherit text color from body */
        }

        footer a {
            color: #3498db; /* Link color for light mode */
        }

        body.dark-mode footer a {
            color: #60a5fa; /* Link color for dark mode */
        }

        /* Dark mode toggle */
        #darkModeToggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.75rem;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.2);
            color: #fff;
            cursor: pointer;
            z-index: 1000;
        }

        /* ...existing styles... */
        body[data-theme="dark"] { color: #e5e7eb; }
        .battle-container { background: rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px); width: 100%; max-width: 1200px; text-align: center; }
        .health-bar { height: 20px; border-radius: 5px; margin: 10px 0; background-color: #e5e7eb; position: relative; }
        .health-fill { height: 100%; border-radius: 5px; position: absolute; transition: width 0.3s ease; }
        .player-health { background-color: #34d399; }
        .opponent-health { background-color: #f87171; }
        .monster { display: flex; align-items: center; justify-content: flex-start; margin-bottom: 20px; }
        .monster img { width: 100px; height: 100px; margin-right: 20px; border-radius: 8px; }
        .monster-info { text-align: left; color: inherit; /* Inherit text color from body */ }
        .monster-info ul { list-style: none; padding: 0; margin: 0; }
        .monster-name { color: #3498db; /* Consistent color for monster names */ }
        body.dark-mode .monster-name { color: #60a5fa; /* Lighter blue for dark mode */ }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .battle-log { background: rgba(0, 0, 0, 0.1); /* Slightly darker background for better contrast */ border-radius: 8px; padding: 10px; margin: 20px 0; max-height: 150px; overflow-y: auto; color: inherit; text-align: center; /* Center the text */ }
        .timer { font-size: 16px; font-weight: bold; margin-top: 10px; color: inherit; /* Inherit text color from body */ } body[data-theme="dark"] .timer {color: inherit; /* Remove the specific color override */}
        .start-battle-button { padding: 1rem 2rem; margin-bottom: 2rem; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; cursor: pointer; font-size: 1.2rem; }
        .start-battle-button:hover { background: linear-gradient(135deg, #34495e, #2980b9); }
        .nav-button { padding: 1rem; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; font-size: 0.95rem; cursor: pointer; transition: all 0.3s ease; text-align: center; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); background: linear-gradient(135deg, #34495e, #2980b9); }
        .nav-button:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }

        /* Add new styles for battle preview */
        .battle-preview {
            text-align: center;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            box-sizing: border-box;
            max-width: 900px; /* Limit maximum width */
            margin: 0 auto;
        }

        .versus-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
        }

        .monster-preview {
            flex: 1;
            min-width: 200px; /* Consistent width for both sides */
            max-width: 200px; /* Fixed maximum width */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .monster-preview img {
            width: 100px; /* Smaller images */
            height: 100px;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .monster-preview h3 {
            margin: 0;
            font-size: 1rem;
            color: #3498db;
        }

        .monster-preview p {
            margin: 0.5rem 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .versus-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3498db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            padding: 0 0.5rem;
            flex: 0 0 auto; /* Prevent VS from growing */
        }

        /* Updated mobile styles */
        @media (max-width: 480px) {
            .versus-display {
                padding: 0 0.5rem;
                gap: 0.25rem;
            }

            .monster-preview {
                min-width: 140px;
                padding: 0.5rem;
            }

            .monster-preview img {
                width: 80px;
                height: 80px;
            }

            .versus-text {
                font-size: 1.25rem;
                padding: 0 0.25rem;
            }

            .monster-preview h3 {
                font-size: 0.9rem;
            }

            .monster-preview p {
                font-size: 0.8rem;
            }
        }

        .xp-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .xp-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }

        .xp-text {
            font-size: 0.9rem;
            color: #a8b3cf;
            margin: 0.25rem 0;
        }

        /* Add monster image container styles */
        .monster-image-container {
            width: 100%;
            height: 280px;
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(128, 128, 128, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Update existing placeholder styles */
        .monster-image-placeholder {
            width: 100%;
            height: 280px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .monster-image-placeholder::before {
            content: 'ðŸ‘¹';
            font-size: 3rem;
            opacity: 0.5;
        }

        .monster-image-placeholder::after {
            content: 'Monster appearance placeholder';
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            padding: 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* Battle-specific image styles */
        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            height: 200px;
            margin: 0.5rem 0;
        }

        .battle-container .monster .monster-image-container,
        .battle-container .monster .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
        }

        @media (max-width: 480px) {
            .monster-image-container,
            .monster-image-placeholder {
                height: 200px;
            }
            
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                width: 100px;
                height: 100px;
            }
        }

        /* Update battle preview styles for consistency */
        .monster-preview {
            flex: 1;
            min-width: 200px; /* Consistent width for both sides */
            max-width: 200px; /* Fixed maximum width */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            width: 150px;  /* Fixed width */
            height: 150px; /* Fixed height */
            margin: 0.5rem auto;
            border-radius: 8px;
        }

        .monster-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .versus-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem; /* Increased gap between monsters */
            width: 100%;
            padding: 1rem;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview {
                min-width: 140px;
                max-width: 140px;
                padding: 0.75rem;
            }

            .monster-preview .monster-image-container,
            .monster-preview .monster-image-placeholder {
                width: 120px;
                height: 120px;
            }

            .versus-display {
                gap: 1rem;
            }
        }

        /* Updated monster preview container styles for perfect matching */
        .monster-preview {
            flex: 0 0 200px; /* Fixed width, no growing or shrinking */
            width: 200px;
            height: 300px; /* Fixed height for both containers */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Evenly space content */
        }

        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0.5rem auto;
            border-radius: 8px;
        }

        .versus-display {
            display: flex;
            align-items: center; /* Center vertically */
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            width: 100%;
            max-width: 700px; /* Limit maximum width */
            margin: 0 auto;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview {
                flex: 0 0 140px;
                width: 140px;
                height: 250px;
                padding: 0.75rem;
            }

            .monster-preview .monster-image-container,
            .monster-preview .monster-image-placeholder {
                width: 120px;
                height: 120px;
            }

            .versus-display {
                gap: 1rem;
            }
        }

        /* Update battle log styles */
        .battle-log {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
            max-height: 150px;
            overflow-y: auto;
            color: inherit;
            text-align: center; /* Center the text */
        }

        .battle-log ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .battle-log li {
            margin: 5px 0;
            line-height: 1.4;
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 9999; /* Ensure toasts are above everything */
            pointer-events: none; /* Prevent toast from blocking interactions */
        }

        .toast.error {
            background: rgba(231, 76, 60, 0.9);
        }

        /* Level up toast specific styles */
        .toast.level-up {
            background: rgba(241, 196, 15, 0.9); /* Yellow background for level up */
            bottom: 90px; /* Position above the regular toast */
            z-index: 10000; /* Higher than regular toast */
        }

        .toast.defeat {
            background: rgba(231, 76, 60, 0.95) !important; /* Red background for defeat */
        }

        /* Add these new styles */
        .victory-text {
            color: #2ecc71;
            font-size: 1.5em;
            margin: 1rem 0;
        }
        
        .defeat-text {
            color: #e74c3c;
            font-size: 1.5em;
            margin: 1rem 0;
        }

        /* Update the battle container image styles */
        .battle-container .monster .monster-image-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
        }

        .battle-container .monster .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                width: 100px;
                height: 100px;
            }
        }

        /* Update the battle container monster image styles */
        .battle-container .monster .monster-image-container,
        .battle-container .monster .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .battle-container .monster .monster-image-container img {
            max-width: 150px;
            max-height: 150px;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                width: 100px;
                height: 100px;
            }

            .battle-container .monster .monster-image-container img {
                max-width: 100px;
                max-height: 100px;
            }
        }

        /* Fix battle container monster image sizing */
        .battle-container .monster {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 20px;
            gap: 1rem;
        }

        .battle-container .monster .monster-image-container {
            flex: 0 0 150px;  /* Fixed width, no growing or shrinking */
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .battle-container .monster .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .battle-container .monster .monster-image-placeholder {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                flex: 0 0 100px;
                width: 100px;
                height: 100px;
            }
        }

        /* Update battle container monster image styles */
        .battle-container .monster .monster-image-container {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .battle-container .monster .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .battle-container .monster .monster-image-placeholder {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                flex: 0 0 100px;
                width: 100px;
                height: 100px;
            }
        }

        /* Update preview monster image styles */
        .monster-preview .monster-image-container {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0.5rem auto;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .monster-preview .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview .monster-image-container {
                width: 120px;
                height: 120px;
            }
        }

        /* Add logo size control */
        .logo-container {
            width: 35%;  /* Changed from 65% to 35% */
            max-width: 300px;  /* Changed from 400px to 300px */
            margin: 0 auto 2rem auto;
        }

        .logo-container img {
            width: 100%;
            height: auto;
            display: block; /* Added to prevent any spacing issues */
            object-fit: contain;
        }

        .monster-image-container {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            will-change: transform;
            transform: translateZ(0);
        }

        /* Enhanced mobile image stability */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                contain: strict;
                isolation: isolate;
                transform: translateZ(0);
                backface-visibility: hidden;
                perspective: 1000;
                -webkit-transform: translateZ(0);
                -webkit-backface-visibility: hidden;
                -webkit-perspective: 1000;
            }

            .battle-container .monster .monster-image-container img {
                contain: strict;
                transform: translateZ(0);
                backface-visibility: hidden;
                -webkit-transform: translateZ(0);
                -webkit-backface-visibility: hidden;
                image-rendering: -webkit-optimize-contrast;
                pointer-events: none;
            }
        }

        /* Update monster image container styles for better performance */
        .monster-image-container {
            contain: layout size;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            isolation: isolate;
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0;
            flex: 0 0 150px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.1);
        }

        .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            pointer-events: none;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000px;
            perspective: 1000px;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
        }

        /* Mobile-specific optimizations */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                width: 100px;
                height: 100px;
                flex: 0 0 100px;
            }
        }

        /* Add optimized GPU acceleration styles */
        .monster-image-container {
            /* ...existing styles... */
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;
            -webkit-transform-style: preserve-3d;
            isolation: isolate;
            contain: content;
        }

        .monster-image-container img {
            /* ...existing styles... */
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            perspective: 1000;
        }

        /* iOS specific optimizations */
        @supports (-webkit-overflow-scrolling: touch) {
            .monster-image-container {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            .monster-image-container img {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }

        /* Add new stable image classes */
        .monster-image-stable {
            contain: layout size;
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            isolation: isolate;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .monster-image-stable img {
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Add iOS-specific optimizations */
        @supports (-webkit-overflow-scrolling: touch) {
            .monster-image-stable {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                contain: strict;
            }
            
            .monster-image-stable img {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                contain: strict;
            }
        }
    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">ðŸŒ™</button>

    <div class="battle-container">
        <div class="logo-container">
            <img src="assets/images/BarcodeLogo1.PNG" alt="Barcode Masters Logo">
        </div>

        <!-- Add battle preview section -->
        <div id="battlePreview" class="battle-preview">
            <div class="versus-display">
                <div class="monster-preview">
                    <h3 id="playerMonsterName">Your Monster</h3>
                    <div id="playerMonsterImage">
                        <!-- Image container will be dynamically inserted here -->
                    </div>
                    <p id="playerMonsterStats">Loading stats...</p>
                </div>
                <div class="versus-text">VS</div>
                <div class="monster-preview">
                    <h3>AI Monster</h3>
                    <div class="monster-image-placeholder"></div>
                    <p>Loading...</p>
                </div>
            </div>
            <button class="nav-button start-battle-button" onclick="startBattle()">Start Battle</button>
        </div>

        <div id="root"></div>

        <!-- Hide this back to profile button once battle starts -->
        <div class="navigation-grid" style="margin-top: 2rem;">
            <button class="nav-button" onclick="location.href='monster-collection.html'">Back to Profile</button>
        </div>

        <footer>
            <p>Version: <span id="versionNumber">1.0.043</span></p>
            <p>&copy; 2025 Barcode Masters | <a href="/barcodemasters/changelog.html">Change Log</a> | <a href="/barcodemasters/privacy-policy.html">Privacy Policy</a></p>
        </footer>
    </div>

    <script type="text/babel">
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDoIWAIUt4HC1RcNmdfXozEr0NG65GO63s",
            authDomain: "barcodemasters-b4b9b.firebaseapp.com",
            projectId: "barcodemasters-b4b9b",
            storageBucket: "barcodemasters-b4b9b.firebasestorage.app",
            messagingSenderId: "827677074735",
            appId: "1:827677074735:web:3bace3d02034348bc82dda"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth(); // Add this line
        const storage = firebase.storage(); // Add this line

        // Add this function before the BattleSystem component and updatePreview function
        const getMonsterImageHTML = (monster) => {
            if (!monster?.imageUrl) {
                return `<div class="monster-image-placeholder"></div>`;
            }
            
            return `
                <div class="monster-image-container">
                    <img src="${monster.imageUrl}" 
                        alt="${monster.monsterName}" 
                        onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\'monster-image-placeholder\'></div>';" 
                    />
                </div>`;
        };

        // Update the getRandomAIOpponentImage function
        async function getRandomAIOpponentImage() {
            // Check if we already have an image URL stored
            const storedUrl = sessionStorage.getItem('aiOpponentImage');
            if (storedUrl) {
                return storedUrl;
            }

            try {
                const totalImages = 12;
                const randomNumber = Math.floor(Math.random() * totalImages) + 1;
                const paddedNumber = String(randomNumber).padStart(2, '0');
                const imagePath = `robotAiOpponent-images/robotAiOpponent_${paddedNumber}.png`;
                
                const imageRef = storage.ref().child(imagePath);
                const url = await imageRef.getDownloadURL();
                
                // Store the URL in sessionStorage
                sessionStorage.setItem('aiOpponentImage', url);
                return url;
            } catch (error) {
                console.error('Error getting AI opponent image:', error);
                return null;
            }
        }

        // Update the calculateAILevel function
        function calculateAILevel(playerLevel) {
            // Generate a random number between 0 and 2 (inclusive) instead of 0 to 3
            const levelBonus = Math.floor(Math.random() * 3);  // 0 to 2
            // AI will be equal to player level or up to 2 levels higher
            return playerLevel + levelBonus;
        }

        const BattleSystem = () => {
            // Add isDefending state
            const [isDefending, setIsDefending] = React.useState(false);
            
            const [playerMonster, setPlayerMonster] = React.useState(null);
            const [opponentMonster, setOpponentMonster] = React.useState(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const playerLevel = parseInt(urlParams.get('level')) || 1;
                const opponentLevel = parseInt(sessionStorage.getItem('aiOpponentLevel')) || playerLevel;
                
                // Balanced base stats for AI
                const baseHP = 25;  // Decreased from 25 to 20
                const baseAP = 5;   // Decreased from 6 to 5
                const baseSpeed = 5; // Decreased from 6 to 5
                
                // Slightly reduced scaling factors
                const hpScaling = 0.40;  // Decreased from 0.45 to 0.40
                const apScaling = 0.20;  // Decreased from 0.25 to 0.20
                const speedScaling = 0.15; // Decreased from 0.20 to 0.15
                
                // Keep same level multiplier
                const levelMultiplier = opponentLevel > 3 ? 1 + ((opponentLevel - 3) * 0.1) : 1;
                
                const scaledHP = Math.round((baseHP * (1 + (opponentLevel - 1) * hpScaling)) * levelMultiplier);
                const scaledAP = Math.round((baseAP * (1 + (opponentLevel - 1) * apScaling)) * levelMultiplier);
                const scaledSpeed = Math.round((baseSpeed * (1 + (opponentLevel - 1) * speedScaling)) * levelMultiplier);
                
                return {
                    monsterName: `Level ${opponentLevel} AI Monster`,
                    type: "Robot",
                    level: opponentLevel,
                    HP: scaledHP,
                    AP: scaledAP,
                    Speed: scaledSpeed
                };
            });

            const [playerHealth, setPlayerHealth] = React.useState(100);
            const [opponentHealth, setOpponentHealth] = React.useState(opponentMonster.HP); // Also update initial health to match max HP
            const [battleLog, setBattleLog] = React.useState([]);
            const [isBattleOver, setIsBattleOver] = React.useState(false);
            const [isPlayerTurn, setIsPlayerTurn] = React.useState(true);
            const [timeRemaining, setTimeRemaining] = React.useState(6 * 60 * 60); // 6 hours in seconds
            const [opponentTimeRemaining, setOpponentTimeRemaining] = React.useState(5 * 60 * 60 + 59 * 60 + 59); // 5 hours + 59 minutes + 59 seconds
            const [battleState, setBattleState] = React.useState('ongoing'); // 'ongoing', 'victory', 'defeat'
            const [aiImageUrl, setAiImageUrl] = React.useState(null); // Add state for AI image

            // Fetch player monster from URL
            React.useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const monsterId = urlParams.get('id');
                
                if (monsterId) {
                    fetchMonsterData(monsterId).then(monsterData => {
                        if (monsterData) {
                            setPlayerMonster(monsterData);
                            setPlayerHealth(monsterData.HP);
                        }
                    });
                }
            }, []);

            // Update the useEffect for AI image
            React.useEffect(() => {
                // Get the stored image URL instead of generating a new one
                const storedUrl = sessionStorage.getItem('aiOpponentImage');
                if (storedUrl) {
                    setAiImageUrl(storedUrl);
                }
            }, []);

            // Format the timer
            const formatTime = (seconds) => {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = seconds % 60;
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            };

            // Main battle cycle (player turn / opponent turn)
            React.useEffect(() => {
                if (isPlayerTurn && !isBattleOver) {
                    const startTime = Date.now();
                    const initialTimeRemaining = timeRemaining;
                    let animationFrameId;
                    let lastUpdate = 0;

                    const updateTimer = () => {
                        const now = Date.now();
                        const elapsedSeconds = Math.floor((now - startTime) / 1000);

                        if (elapsedSeconds > lastUpdate) {
                            lastUpdate = elapsedSeconds;
                            const newTime = initialTimeRemaining - elapsedSeconds;

                            if (newTime <= 1) {
                                setIsPlayerTurn(false);
                                setTimeRemaining(6 * 60 * 60);
                                return;
                            }

                            setTimeRemaining(newTime);
                        }

                        animationFrameId = requestAnimationFrame(updateTimer);
                    };

                    animationFrameId = requestAnimationFrame(updateTimer);

                    return () => {
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                    };
                } else if (!isPlayerTurn && !isBattleOver && opponentHealth > 0) {
                    let animationFrameId;
                    const startTime = Date.now();
                    let lastUpdate = Date.now();

                    const updateOpponentTimer = () => {
                        const now = Date.now();
                        if (now - lastUpdate >= 1000) {
                            setOpponentTimeRemaining(prev => prev - 1);
                            lastUpdate = now;
                        }
                        animationFrameId = requestAnimationFrame(updateOpponentTimer);
                    };

                    animationFrameId = requestAnimationFrame(updateOpponentTimer);

                    const randomDelay = Math.floor(Math.random() * 4000) + 1000;
                    const actionTimer = setTimeout(() => {
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                        setOpponentTimeRemaining(5 * 60 * 60 + 59 * 60);
                        opponentTurn();
                    }, randomDelay);

                    return () => {
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                        clearTimeout(actionTimer);
                    };
                }
            }, [isPlayerTurn, isBattleOver, opponentHealth]);

            // Add messages to battle log
            const addToLog = (message) => {
                let emoji = '';
                if (message.includes('dealt')) {
                    emoji = 'ðŸ’ª '; // Note the space after emoji
                } else if (message.includes('Critical Hit')) {
                    emoji = 'ðŸ’¥ ';
                } else if (message.includes('healed')) {
                    emoji = 'â¤ï¸ ';
                } else if (message.includes('won')) {
                    emoji = 'ðŸ† ';
                } else if (message.includes('lost')) {
                    emoji = 'âŒ ';
                } else if (message.includes('defending')) {
                    emoji = 'ðŸ›¡ï¸ ';
                }
                setBattleLog(prevLog => [...prevLog, `${emoji}${message}`].slice(-5));
            };

            // Check for win/loss conditions
            const checkBattleOutcome = () => {
                if (opponentHealth <= 0 && !isBattleOver) {
                    handleVictory();
                } else if (playerHealth <= 0 && !isBattleOver) {
                    handleDefeat();
                }
            };

            // Player action handlers
            // Update the damage calculation functions
            const calculateDamage = (attacker, isPlayer = true) => {
                const baseAP = Math.max(1, parseInt(attacker.AP) || 1);
                const variance = Math.floor((Math.random() * 0.3 - 0.15) * baseAP); // Increased variance
                
                // base damage for player
                let damage = isPlayer ? 
                    baseAP * 1.00 + variance : // Player deals 85% of AP
                    baseAP + variance;         // AI deals full AP
                
                // Ensure minimum damage
                damage = Math.max(1, Math.floor(damage));
                
                // Critical hit chances
                const criticalChance = isPlayer ? 0.1 : 0.15; // AI has higher crit chance
                const criticalMultiplier = isPlayer ? 1.5 : 1.75; // AI crits hit harder
                
                if (Math.random() < criticalChance) {
                    damage = Math.floor(damage * criticalMultiplier);
                    return { damage, isCritical: true };
                }
                
                return { damage, isCritical: false };
            };

            // Replace the handleAttack function with this version:
            const handleAttack = async () => {
                if (isBattleOver || !isPlayerTurn) return;
    
                const { damage, isCritical } = calculateDamage(activeMonster, true);
                const newHealth = Math.max(0, opponentHealth - damage);
    
                if (newHealth <= 0) {
                    // Process victory before changing any state
                    await handleVictory();
                    setOpponentHealth(0);
                    setIsBattleOver(true);
                    return;
                }
    
                setOpponentHealth(newHealth);
                addToLog(`You dealt ${damage} damage!${isCritical ? ' (Critical Hit!)' : ''}`);
                setIsPlayerTurn(false);
            };

            // Add the victory handler
            const handleVictory = async () => {
                console.log('Starting victory handler with:', {
                    playerMonster,
                    isBattleOver,
                    opponentHealth
                });
                
                // Add check for valid monster data
                if (!playerMonster?.id) {
                    console.log('No valid monster ID found:', playerMonster);
                    return;
                }
                
                if (isBattleOver) {
                    console.log('Battle already over, stopping victory handler');
                    return;
                }

                console.log('Processing victory...');
                setBattleState('victory');
                setIsBattleOver(true);
                setOpponentHealth(0);

                try {
                    // Calculate XP gain
                    const baseXP = 25;
                    const levelBonus = Math.floor(opponentMonster.level * 7.5);
                    const totalExp = Math.floor(baseXP + levelBonus + (Math.random() * 10 - 5));

                    console.log('XP calculation:', { baseXP, levelBonus, totalExp });

                    // Update battle log and show toast
                    addToLog(`ðŸ† Victory! Earned ${totalExp} XP!`);
                    showToast(`Victory! Gained ${totalExp} XP! ðŸŽ‰`);

                    // Get current monster data
                    const monsterRef = db.collection('monsters').doc(playerMonster.id);
                    const doc = await monsterRef.get();
                    
                    if (!doc.exists) {
                        throw new Error('Monster document not found');
                    }

                    // Parse current values
                    const currentExp = parseInt(doc.data().experience) || 0;
                    const currentLevel = parseInt(doc.data().level) || 1;
                    const newExp = currentExp + totalExp;

                    console.log('Experience update:', { 
                        currentExp, 
                        totalExp, 
                        newExp, 
                        currentLevel 
                    });

                    const updates = { experience: newExp };

                    // Check for level up
                    if (newExp >= currentLevel * 100) {
                        const newLevel = currentLevel + 1;
                        updates.level = newLevel;
                        updates.HP = Math.round(doc.data().HP * 1.2);
                        updates.AP = Math.round(doc.data().AP * 1.15);
                        updates.Speed = Math.round(doc.data().Speed * 1.1);

                        console.log('Level up detected:', updates);

                        // Show level up notifications after a delay
                        setTimeout(() => {
                            showToast(`Level Up! Your monster is now level ${newLevel}! ðŸŒŸ`, true);
                            addToLog(`ðŸŒŸ Level Up! Now level ${newLevel}!`);
                        }, 1500);
                    }

                    // Update Firestore
                    console.log('Updating Firestore with:', updates);
                    await monsterRef.update(updates);
                    console.log('Firestore update successful');

                    // Update local state
                    setPlayerMonster(prev => ({
                        ...prev,
                        experience: newExp,
                        level: updates.level || prev.level,
                        HP: updates.HP || prev.HP,
                        AP: updates.AP || prev.AP,
                        Speed: updates.Speed || prev.Speed
                    }));

                } catch (error) {
                    console.error('Victory processing error:', error);
                    showToast('Error processing victory rewards! âŒ', false);
                    addToLog('âŒ Error processing victory rewards');
                }
            };

            // Update handleDefend function
            const handleDefend = () => {
                setIsDefending(true);
                addToLog("You're defending against the next attack! (Damage will be halved)");
                setIsPlayerTurn(false);
            };

            // Update handleHeal function with percentage-based healing
            const handleHeal = () => {
                // Healing scales with level and gets less effective at higher HP
                const baseHealPercent = 0.42; // Heal player amount
                const currentHPPercent = playerHealth / activeMonster.HP;
                const healEffectiveness = 1 - (currentHPPercent * 0.5); // Reduced healing at higher HP
                
                const healAmount = Math.floor(
                    activeMonster.HP * baseHealPercent * healEffectiveness
                );
                
                setPlayerHealth(prev => {
                    const newHealth = Math.min(parseInt(activeMonster.HP), prev + healAmount);
                    addToLog(`You healed for ${newHealth - prev} HP!`);
                    return newHealth;
                });
                setIsPlayerTurn(false);
            };

            // Opponent AI behavior
            // Update opponentTurn with smarter AI behavior
            const opponentTurn = async () => {
                if (isBattleOver || isPlayerTurn || playerHealth <= 0) return;

                // AI decision making based on health percentage
                const aiHealthPercentage = opponentHealth / opponentMonster.HP;
                const playerHealthPercentage = playerHealth / activeMonster.HP;

                // Choose action based on situation
                let action = 'attack'; // Default action

                if (aiHealthPercentage < 0.3) {
                    // When critically low on health
                    const random = Math.random();
                    if (random < 0.6) { // 60% chance to heal when critical
                        action = 'heal';
                    } else if (random < 0.9) { // 30% chance to defend
                        action = 'defend';
                    }
                    // 10% chance to still attack
                } else if (aiHealthPercentage < 0.5) {
                    // When moderately low on health
                    const random = Math.random();
                    if (random < 0.4) { // 40% chance to heal
                        action = 'heal';
                    } else if (random < 0.7) { // 30% chance to defend
                        action = 'defend';
                    }
                    // 30% chance to attack
                } else if (playerHealthPercentage < 0.3 && aiHealthPercentage > 0.6) {
                    // Aggressive when player is low and AI is healthy
                    const random = Math.random();
                    if (random < 0.8) { // 80% chance to attack
                        action = 'attack';
                    } else { // 20% chance to defend
                        action = 'defend';
                    }
                }

                // Execute the chosen action
                switch (action) {
                    case 'heal':
                        const healPercent = 0.3; // Heal 30% of max HP
                        const healAmount = Math.floor(opponentMonster.HP * healPercent);
                        const newHealth = Math.min(opponentMonster.HP, opponentHealth + healAmount);
                        setOpponentHealth(newHealth);
                        addToLog(`Opponent healed for ${newHealth - opponentHealth} HP!`);
                        break;

                    case 'defend':
                        addToLog("Opponent is defending against the next attack!");
                        // Add a temporary defense buff for the next player's attack
                        window.aiDefending = true;
                        setTimeout(() => { window.aiDefending = false; }, 100);
                        break;

                    default: // Attack
                        const { damage } = calculateDamage(opponentMonster, false);
                        let finalDamage = isDefending ? Math.floor(damage / 1.75) : damage;
                        
                        if (playerHealthPercentage < 0.3) {
                            finalDamage = Math.floor(finalDamage * 1.2); // 20% bonus damage on low HP targets
                        }

                        const newPlayerHealth = Math.max(0, playerHealth - finalDamage);
                        setPlayerHealth(newPlayerHealth);
                        
                        const message = isDefending 
                            ? `Opponent dealt ${finalDamage} damage! (Reduced by defense)`
                            : playerHealthPercentage < 0.3 
                                ? `Opponent dealt ${finalDamage} damage! (Execution bonus)`
                                : `Opponent dealt ${finalDamage} damage!`;
                        
                        addToLog(message);

                        if (newPlayerHealth <= 0) {
                            setIsBattleOver(true);
                            await handleDefeat();
                            return;
                        }
                        break;
                }

                setIsDefending(false);
                setIsPlayerTurn(true);
            };

            // Add the defeat handler
            const handleDefeat = async () => {
                if (!playerMonster?.id || isBattleOver) return;

                setBattleState('defeat');
                setIsBattleOver(true);
                setPlayerHealth(0);

                try {
                    const currentExp = parseInt(playerMonster.experience) || 0;
                    const lostExp = Math.floor(currentExp * 0.1); // Lose 10% of current XP
                    const newExp = Math.max(0, currentExp - lostExp);

                    // Update battle log
                    addToLog(`ðŸ’€ Defeat! Lost ${lostExp} XP!`);
                    
                    // Show toast notification
                    showToast(`Defeat! Lost ${lostExp} XP! âŒ`, false, true);

                    const monsterRef = db.collection('monsters').doc(playerMonster.id);
                    await monsterRef.update({ experience: newExp });

                    // Update local state
                    setPlayerMonster(prev => ({
                        ...prev,
                        experience: newExp
                    }));

                } catch (error) {
                    console.error('Defeat processing error:', error);
                    addToLog('âŒ Error processing defeat penalties');
                }
            };

            const activeMonster = playerMonster || {
                monsterName: "Player Monster",
                type: "Fighter",
                level: 1,
                HP: 100,
                AP: 10,
                Speed: 10
            };

            // Add new function to update monster experience
            const updateMonsterExperience = async (monsterId, expChange) => {
                console.log(`Starting experience update for monster ${monsterId} by ${expChange}`);
                
                try {
                    const monsterRef = db.collection('monsters').doc(monsterId);
                    const monsterDoc = await monsterRef.get();
                    
                    if (!monsterDoc.exists) {
                        console.error('Monster document not found');
                        throw new Error('Monster not found in database');
                    }

                    const monsterData = monsterDoc.data();
                    console.log('Current monster data:', monsterData);

                    // Ensure numeric values
                    const currentExp = parseInt(monsterData.experience) || 0;
                    const currentLevel = parseInt(monsterData.level) || 1;
                    const newExp = Math.max(0, currentExp + expChange);
                    
                    console.log(`Experience: ${currentExp} -> ${newExp}`);

                    const updates = {
                        experience: newExp
                    };

                    // Check for level up
                    if (expChange > 0) {
                        const expForNextLevel = currentLevel * 100;
                        console.log(`Exp needed for next level: ${expForNextLevel}`);
                        
                        if (newExp >= expForNextLevel) {
                            const newLevel = currentLevel + 1;
                            console.log(`Level up! ${currentLevel} -> ${newLevel}`);
                            
                            // Get base stats
                            const baseHP = parseInt(monsterData.HP) || 10;
                            const baseAP = parseInt(monsterData.AP) || 5;
                            const baseSpeed = parseInt(monsterData.Speed) || 5;

                            // Calculate new stats with level multipliers
                            updates.level = newLevel;
                            updates.HP = Math.round(baseHP * (1 + (newLevel - 1) * 0.2));
                            updates.AP = Math.round(baseAP * (1 + (newLevel - 1) * 0.15));
                            updates.Speed = Math.round(baseSpeed * (1 + (newLevel - 1) * 0.1));

                            console.log('New stats after level up:', updates);
                        }
                    }

                    console.log('Applying updates to database:', updates);
                    await monsterRef.update(updates);
                    console.log('Database update successful');

                    return {
                        success: true,
                        levelUp: updates.level !== undefined,
                        newLevel: updates.level || currentLevel,
                        expChange,
                        newExp,
                        newStats: {
                            HP: updates.HP,
                            AP: updates.AP,
                            Speed: updates.Speed
                        }
                    };

                } catch (error) {
                    console.error('Error in updateMonsterExperience:', error);
                    throw error;
                }
            };

            // Add this function to generate monster image HTML
            const getMonsterImageHTML = (monster) => {
                if (!monster?.imageUrl) {
                    return `<div class="monster-image-placeholder"></div>`;
                }
                
                return `
                    <div class="monster-image-container">
                        <img src="${monster.imageUrl}" 
                            alt="${monster.monsterName}" 
                            onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\'monster-image-placeholder\'></div>';" 
                        />
                    </div>`;
            };

            // Add helper function to generate image content
            const MonsterImage = React.memo(({ monster, isAI = false }) => {
                const containerRef = React.useRef(null);
                const imageRef = React.useRef(null);
                
                const imageUrl = React.useMemo(() => 
                    isAI ? aiImageUrl : monster?.imageUrl,
                    [isAI, aiImageUrl, monster?.imageUrl]
                );

                React.useEffect(() => {
                    if (containerRef.current) {
                        // Force hardware acceleration
                        containerRef.current.style.transform = 'translate3d(0,0,0)';
                    }
                    if (imageRef.current) {
                        // Ensure image is hardware accelerated
                        imageRef.current.style.transform = 'translate3d(0,0,0)';
                    }
                }, []);

                return React.useMemo(() => (
                    <div 
                        ref={containerRef}
                        className="monster-image-container monster-image-stable"
                    >
                        {imageUrl ? (
                            <img 
                                ref={imageRef}
                                src={imageUrl}
                                alt={isAI ? "AI Opponent" : monster?.monsterName}
                                loading="eager"
                                decoding="sync"
                            />
                        ) : (
                            <div className="monster-image-placeholder"></div>
                        )}
                    </div>
                ), [imageUrl, isAI, monster?.monsterName]);
            }, (prevProps, nextProps) => {
                return prevProps.isAI === nextProps.isAI &&
                       prevProps.monster?.imageUrl === nextProps.monster?.imageUrl &&
                       prevProps.monster?.monsterName === nextProps.monster?.monsterName;
            });

            // Add showToast function
            const showToast = (message, isLevelUp = false, isDefeat = false) => {
                console.log('showToast called:', { message, isLevelUp, isDefeat }); // Debug log
                
                const toastId = isLevelUp ? 'levelUpToast' : 'battleToast';
                let toast = document.getElementById(toastId);
                
                // Remove existing toast
                if (toast) {
                    console.log('Removing existing toast:', toastId);
                    toast.remove();
                }
                
                // Create new toast
                toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast${isLevelUp ? ' level-up' : ''}${isDefeat ? ' defeat' : ''}`;
                toast.textContent = message;
                
                console.log('Creating new toast:', { id: toastId, message }); // Debug log
                document.body.appendChild(toast);
                
                // Force reflow and add debug logging
                void toast.offsetWidth;
                console.log('Toast element:', toast);
                console.log('Toast styles:', window.getComputedStyle(toast));
                
                // Show toast with debugging
                requestAnimationFrame(() => {
                    toast.style.transform = 'translateY(0)';
                    toast.style.opacity = '1';
                    console.log('Toast animation started');
                });

                // Hide and remove toast after delay
                setTimeout(() => {
                    console.log('Starting toast removal animation');
                    toast.style.transform = 'translateY(100px)';
                    toast.style.opacity = '0';
                    
                    setTimeout(() => {
                        if (toast.parentElement) {
                            toast.parentElement.removeChild(toast);
                            console.log('Toast removed from DOM');
                        }
                    }, 300);
                }, 5000);
            };

            // Add calculateBattleRewards function
            const calculateBattleRewards = () => {
                const levelDifference = opponentMonster.level - playerMonster.level;
                const baseXP = 15;
                
                // Bonus XP for defeating higher level opponents, reduced XP for lower level
                const levelBonus = Math.floor(opponentMonster.level * 7.5);
                const difficultyMultiplier = 1 + (levelDifference * 0.1); // 10% more/less XP per level difference
                
                const randomFactor = (Math.random() * 10) - 5;
                return Math.max(1, Math.floor((baseXP + levelBonus) * difficultyMultiplier + randomFactor));
            };

            // Add this useEffect inside the component
            React.useEffect(() => {
                if (!isBattleOver) {
                    if (opponentHealth <= 0) {
                        handleVictory();
                    } else if (playerHealth <= 0) {
                        handleDefeat();
                    }
                }
            }, [opponentHealth, playerHealth]);

            // Update the return JSX
            return (
                <div className="battle-container">
                    <h2>{activeMonster.monsterName} vs {opponentMonster.monsterName}</h2>
                    
                    <div className="monster">
                        <MonsterImage monster={playerMonster} />
                        <div className="monster-info">
                            <ul>
                                <li>Type: {activeMonster.type}</li>
                                <li>Level: {activeMonster.level}</li>
                                <li>HP: {playerHealth}/{activeMonster.HP}</li>
                                <li>AP: {activeMonster.AP}</li>
                                <li>Speed: {activeMonster.Speed}</li>
                                <li className="xp-text">XP: {activeMonster.experience || 0}/{activeMonster.level * 100}</li>
                            </ul>
                            <div className="xp-progress">
                                <div 
                                    className="xp-progress-bar" 
                                    style={{ width: `${((activeMonster.experience || 0) % (activeMonster.level * 100)) / (activeMonster.level * 100) * 100}%` }}
                                ></div>
                            </div>
                        </div>
                    </div>
                    <div className="health-bar">
                        <div 
                            className="health-fill player-health" 
                            style={{ width: `${(playerHealth / activeMonster.HP) * 100}%` }}
                        ></div>
                    </div>

                    <div className="monster">
                        <MonsterImage monster={opponentMonster} isAI={true} />
                        <div className="monster-info">
                            <ul>
                                <li>Type: {opponentMonster.type}</li>
                                <li>Level: {opponentMonster.level}</li>
                                <li>HP: {opponentHealth}/{opponentMonster.HP}</li>
                                <li>AP: {opponentMonster.AP}</li>
                                <li>Speed: {opponentMonster.Speed}</li>
                            </ul>
                        </div>
                    </div>
                    <div className="health-bar">
                        <div 
                            className="health-fill opponent-health" 
                            style={{ width: `${(opponentHealth / opponentMonster.HP) * 100}%` }}
                        ></div>
                    </div>

                    <div className="battle-log">
                        <ul>
                            {battleLog.map((entry, index) => (
                                <li key={index}>{entry}</li>
                            ))}
                        </ul>
                    </div>

                    {/* Timer */}
                    <div className="timer">
                        {isPlayerTurn ? (
                            <span>Your turn, time remaining: {formatTime(timeRemaining)}</span>
                        ) : (
                            <span>Opponent's turn, time remaining: {formatTime(opponentTimeRemaining)}</span>
                        )}
                    </div>

                    <div className="battle-controls">
                        {!isBattleOver && isPlayerTurn ? (
                            <div>
                                <button onClick={handleAttack} disabled={isBattleOver || battleState !== 'ongoing'}>
                                    Attack
                                </button>
                                <button onClick={handleDefend} disabled={isBattleOver || battleState !== 'ongoing'}>
                                    Defend
                                </button>
                                <button onClick={handleHeal} disabled={isBattleOver || battleState !== 'ongoing'}>
                                    Heal
                                </button>
                            </div>
                        ) : (
                            <div>
                                {isBattleOver && (
                                    <div>
                                        <h3 className={battleState === 'victory' ? 'victory-text' : 'defeat-text'}>
                                            {opponentHealth <= 0 ? 'ðŸ† Victory!' : 'ðŸ’€ Defeat!'}
                                        </h3>
                                        <button 
                                            className="nav-button" 
                                            onClick={() => window.location.href='monster-collection.html'}
                                        >
                                            Return to Collection
                                        </button>
                                        <button 
                                            className="nav-button" 
                                            onClick={() => window.location.reload()}
                                            style={{marginLeft: '10px'}}
                                        >
                                            Start New Battle
                                        </button>
                                    </div>
                                )}
                                {!isBattleOver && !isPlayerTurn && (
                                    <span>Opponent is thinking...</span>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function startBattle() {
            // Hide the preview
            document.getElementById('battlePreview').style.display = 'none';
            // Hide the back to profile button
            document.querySelector('.navigation-grid').style.display = 'none';
            // Render the battle system
            ReactDOM.render(<BattleSystem />, document.getElementById('root'));
        }

        // Add this function before updatePreview
        async function fetchMonsterData(monsterId) {
            try {
                const monsterRef = db.collection('monsters').doc(monsterId);
                const doc = await monsterRef.get();
                if (doc.exists) {
                    // Include the document ID in the returned data
                    return {
                        id: doc.id,  // Add this line to preserve the ID
                        ...doc.data()
                    };
                }
                console.log('No monster document found');
                return null;
            } catch (error) {
                console.error('Error fetching monster data:', error);
                return null;
            }
        }

        // Update the updatePreview function
        async function updatePreview() {
            const urlParams = new URLSearchParams(window.location.search);
            const monsterId = urlParams.get('id');
            
            if (monsterId) {
                try {
                    // Fetch complete monster data from Firestore
                    const monsterData = await fetchMonsterData(monsterId);
                    if (!monsterData) {
                        console.error('Failed to fetch monster data');
                        return;
                    }

                    console.log('Fetched monster data:', monsterData); // Debug log

                    const playerLevel = parseInt(monsterData.level) || 1;
                    const aiLevel = calculateAILevel(playerLevel);
                    sessionStorage.setItem('aiOpponentLevel', aiLevel);

                    // Update monster name
                    const nameElement = document.getElementById('playerMonsterName');
                    if (nameElement) {
                        nameElement.textContent = monsterData.monsterName || 'Your Monster';
                    }

                    // Update monster image with imageUrl from Firestore
                    const imageContainer = document.getElementById('playerMonsterImage');
                    if (imageContainer) {
                        console.log('Setting monster image with URL:', monsterData.imageUrl); // Debug log
                        imageContainer.innerHTML = getMonsterImageHTML({
                            ...monsterData,
                            imageUrl: monsterData.imageUrl // Ensure imageUrl is included
                        });
                    }

                    // Update monster stats
                    const statsElement = document.getElementById('playerMonsterStats');
                    if (statsElement) {
                        const stats = [
                            `Level ${monsterData.level || '1'}`,
                            monsterData.type || 'Unknown',
                            `HP: ${monsterData.HP || '100'}`,
                            `AP: ${monsterData.AP || '10'}`,
                            `Speed: ${monsterData.Speed || '10'}`
                        ];
                        statsElement.textContent = stats.join(' | ');
                    }

                    // Update AI opponent preview
                    const aiPreviewElement = document.querySelector('.monster-preview:last-child p');
                    if (aiPreviewElement) {
                        const aiStats = [
                            `Level ${aiLevel}`,
                            'Type: Robot',
                            `HP: ${Math.round(20 * (1 + (aiLevel - 1) * 0.40))}`, // Updated values
                            `AP: ${Math.round(5 * (1 + (aiLevel - 1) * 0.20))}`,  // Updated values
                            `Speed: ${Math.round(5 * (1 + (aiLevel - 1) * 0.15))}` // Updated values
                        ];
                        aiPreviewElement.textContent = aiStats.join(' | ');
                    }

                    const aiNameElement = document.querySelector('.monster-preview:last-child h3');
                    if (aiNameElement) {
                        aiNameElement.textContent = `AI Monster (Lvl ${aiLevel})`;
                    }

                    // Add AI opponent image to preview
                    const aiImageUrl = await getRandomAIOpponentImage();
                    const aiPreviewImage = document.querySelector('.monster-preview:last-child .monster-image-placeholder');
                    if (aiPreviewImage && aiImageUrl) {
                        aiPreviewImage.outerHTML = `
                            <div class="monster-image-container">
                                <img src="${aiImageUrl}" 
                                    alt="AI Opponent" 
                                    onerror="this.onerror=null; this.parentElement.innerHTML='<div class="monster-image-placeholder"></div>';" 
                                />
                            </div>`;
                    }
                } catch (error) {
                    console.error('Error in updatePreview:', error);
                }
            }
        }

        // Call updatePreview when page loads
        window.addEventListener('load', updatePreview);

        // Dark mode toggle
        const darkModeToggle = document.getElementById("darkModeToggle");
        const savedTheme = localStorage.getItem("theme");
        
        if (savedTheme === "dark") {
            document.body.classList.add("dark-mode");
        }

        darkModeToggle.addEventListener("click", function() {
            document.body.classList.toggle("dark-mode");
            localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        });

        // Clean up event listeners
        window.addEventListener('load', () => {
            updatePreview();
            return () => {
                // Remove event listeners
                darkModeToggle.removeEventListener('click');
            };
        });
    </script>
</body>
</html>
