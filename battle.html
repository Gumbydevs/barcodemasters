<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Barcode Masters - Battle System</title>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-auth-compat.js"></script>
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-storage-compat.js"></script>
    <script src="monsterStats.js"></script>
    <style>
        /* Collection-style layout */
        body { 
            font-family: Arial, sans-serif; 
            background-color: #f3f4f6; 
            color: #070707; /* Default text color for light mode */
            margin: 0; 
            padding: 0; 
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            justify-content: center; /* Center content vertically */
            align-items: center; /* Center content horizontally */
        }
        
        body.dark-mode {
            background: #121212 !important;  /* Updated from any previous color to match monster-collection */
            color: #ffffff; /* Text color for dark mode */
        }

        .battle-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            padding-top: 2rem; /* Reduced padding-top */
            padding-bottom: 2rem; /* Reduced padding-bottom */
            box-sizing: border-box;
            color: inherit; /* Inherit text color from body */
            background: rgba(12, 12, 12, 0.1);
            border-radius: 12px;
        }

        body.dark-mode .battle-container {
            background: rgba(14, 13, 13, 0.7) !important; /* Darker background for dark mode */
        }

        @media (max-width: 480px) {
    .battle-container {
        padding: 0.5rem;
        padding-top: 1rem; /* Reduced padding-top */
        padding-bottom: 1rem; /* Reduced padding-bottom */
        font-size: 0.9rem;
    }

    .monster-info {
        font-size: 0.85rem;
    }

    .monster {
        gap: 0.5rem;
    }

    .health-bar {
        height: 15px;
        margin: 5px 0;
    }

    .battle-controls button {
        padding: 8px 1px;
        font-size: 0.9rem;
        
    }
}

        /* Monster card styling */
        .monster-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 1.5rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .monster-card {
            background: rgba(255, 255, 255, 0.05);
        }

        .monster-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .stat-item {
            text-align: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        /* Navigation grid */
        .navigation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .nav-button {
            padding: 0rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            align-self: top;
        }

        /* Footer */
        footer {
            width: 100%;
            padding: 1rem;
            background: inherit;
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            margin-top: 2rem;
            color: inherit; /* Inherit text color from body */
        }

        footer a {
            color: #3498db; /* Link color for light mode */
        }

        body.dark-mode footer a {
            color: #60a5fa; /* Link color for dark mode */
        }

        /* Dark mode toggle */
        #darkModeToggle {
            position: fixed;
            top: 1rem;
            right: 1rem;
            padding: 0.75rem;
            border-radius: 50%;
            border: none;
            background: rgba(0, 0, 0, 0.2);
            color: #fff;
            cursor: pointer;
            z-index: 1000;
        }

        /* ...existing styles... */
        body[data-theme="dark"] { color: #e5e7eb; }
        .battle-container { background: rgba(255, 255, 255, 0.1); border-radius: 12px; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px); width: 100%; max-width: 1200px; text-align: center; }
        .health-bar { height: 20px; border-radius: 5px; margin: 10px 0; background-color: #e5e7eb; position: relative; }
        .health-fill { height: 100%; border-radius: 5px; position: absolute; transition: width 0.3s ease; }
        .player-health { background-color: #34d399; }
        .opponent-health { background-color: #f87171; }
        .monster { display: flex; align-items: center; justify-content: flex-start; margin-bottom: 20px; }
        .monster img { width: 100px; height: 100px; margin-right: 20px; border-radius: 8px; }
        .monster-info { text-align: left; color: inherit; /* Inherit text color from body */ }
        .monster-info ul { list-style: none; padding: 0; margin: 0; }
        .monster-name { color: #3498db; /* Consistent color for monster names */ }
        body.dark-mode .monster-name { color: #60a5fa; /* Lighter blue for dark mode */ }
        button { padding: 10px 20px; margin: 5px; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; cursor: pointer; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .battle-log { background: rgba(0, 0, 0, 0.1); /* Slightly darker background for better contrast */ border-radius: 8px; padding: 10px; margin: 20px 0; max-height: 50px; overflow-y: auto; color: inherit; font-size:small; text-align: center; /* Center the text */ }
        .timer { display: none; } /* This will hide any existing timer elements */ body[data-theme="dark"] .timer {color: inherit; /* Remove the specific color override */}
        .start-battle-button { padding: 1rem 2rem; margin-bottom: 2rem; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; cursor: pointer; font-size: 1.2rem; }
        .start-battle-button:hover { background: linear-gradient(135deg, #34495e, #2980b9); }
        .nav-button { padding: 1rem; border: none; border-radius: 8px; background: linear-gradient(135deg, #2c3e50, #3498db); color: white; font-size: 0.95rem; cursor: pointer; transition: all 0.3s ease; text-align: center; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .nav-button:hover { transform: translateY(-2px); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15); background: linear-gradient(135deg, #34495e, #2980b9); }
        .nav-button:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }

        /* Add new styles for battle preview */
        .battle-preview {
            text-align: center;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            box-sizing: border-box;
            max-width: 900px; /* Limit maximum width */
            margin: 0 auto;
        }

        .versus-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
        }

        .monster-preview {
            flex: 1;
            min-width: 200px; /* Consistent width for both sides */
            max-width: 200px; /* Fixed maximum width */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .monster-preview img {
            width: 100px; /* Smaller images */
            height: 100px;
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .monster-preview h3 {
            margin: 0;
            font-size: 1rem;
            color: #3498db;
        }

        .monster-preview p {
            margin: 0.5rem 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .versus-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3498db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            padding: 0 0.5rem;
            flex: 0 0 auto; /* Prevent VS from growing */
        }

        /* Updated mobile styles */
        @media (max-width: 480px) {
            .versus-display {
                padding: 0 0.5rem;
                gap: 0.25rem;
            }

            .monster-preview {
                min-width: 140px;
                padding: 0.5rem;
            }

            .monster-preview img {
                width: 80px;
                height: 80px;
            }

            .versus-text {
                font-size: 1.25rem;
                padding: 0 0.25rem;
            }

            .monster-preview h3 {
                font-size: 0.9rem;
            }

            .monster-preview p {
                font-size: 0.8rem;
            }
        }

        .xp-progress {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin: 0.5rem 0;
            overflow: hidden;
        }

        .xp-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            transition: width 0.3s ease;
        }

        .xp-text {
            font-size: 0.9rem;
            color: #a8b3cf;
            margin: 0.25rem 0;
        }

        /* Add monster image container styles */
        .monster-image-container {
            width: 150px;
            height: 150px;
            position: relative;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.1);
            overflow: hidden;
}

.monster-image-container img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    pointer-events: none;
}

/* Mobile adjustments */
@media (max-width: 480px) {
    .monster-image-container {
        width: 100px;
        height: 100px;
    }
}

/* Animations without transforms */
.damage-animation {
    animation: damage-flash 0.5s ease-in-out;
}

.heal-animation {
    animation: heal-pulse 0.8s ease-in-out;
}

@keyframes damage-flash {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.5); }
    100% { filter: brightness(1); }
}

@keyframes heal-pulse {
    0% { filter: brightness(1); }
    50% { filter: brightness(1.5); }
    100% { filter: brightness(1); }
}
        

        .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Update existing placeholder styles */
        .monster-image-placeholder {
            width: 100%;
            height: 280px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .monster-image-placeholder::before {
            content: 'ðŸ‘¹';
            font-size: 3rem;
            opacity: 0.5;
        }

        .monster-image-placeholder::after {
            content: 'Monster appearance placeholder';
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
            padding: 4px;
            background: rgba(0, 0, 0, 0.5);
        }

        /* Battle-specific image styles */
        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            height: 200px;
            margin: 0.5rem 0;
        }

        .battle-container .monster .monster-image-container,
        .battle-container .monster .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
        }

        @media (max-width: 480px) {
            .monster-image-container,
            .monster-image-placeholder {
                height: 200px;
            }
            
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                width: 100px;
                height: 100px;
            }
        }

        /* Update battle preview styles for consistency */
        .monster-preview {
            flex: 1;
            min-width: 200px; /* Consistent width for both sides */
            max-width: 200px; /* Fixed maximum width */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            width: 150px;  /* Fixed width */
            height: 150px; /* Fixed height */
            margin: 0.5rem auto;
            border-radius: 8px;
        }

        .monster-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .versus-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem; /* Increased gap between monsters */
            width: 100%;
            padding: 1rem;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview {
                min-width: 140px;
                max-width: 140px;
                padding: 0.75rem;
            }

            .monster-preview .monster-image-container,
            .monster-preview .monster-image-placeholder {
                width: 120px;
                height: 120px;
            }

            .versus-display {
                gap: 1rem;
            }
        }

        /* Updated monster preview container styles for perfect matching */
        .monster-preview {
            flex: 0 0 200px; /* Fixed width, no growing or shrinking */
            width: 200px;
            height: 300px; /* Fixed height for both containers */
            padding: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            margin: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Evenly space content */
        }

        .monster-preview .monster-image-container,
        .monster-preview .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0.5rem auto;
            border-radius: 8px;
        }

        .versus-display {
            display: flex;
            align-items: center; /* Center vertically */
            justify-content: center;
            gap: 2rem;
            padding: 1rem;
            width: 100%;
            max-width: 700px; /* Limit maximum width */
            margin: 0 auto;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview {
                flex: 0 0 140px;
                width: 140px;
                height: 250px;
                padding: 0.75rem;
            }

            .monster-preview .monster-image-container,
            .monster-preview .monster-image-placeholder {
                width: 120px;
                height: 120px;
            }

            .versus-display {
                gap: 1rem;
            }
        }

        /* Update battle log styles */
        .battle-log {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 10px;
            margin: 20px 0;
            height: 120px; /* Reduced fixed height */
            overflow-y: auto;
            color: inherit;
            text-align: center;
            display: flex;
            flex-direction: column-reverse;
            position: relative;
            margin-bottom: 10px; /* Add space between log and buttons */
        }

        .battle-log ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column-reverse; /* Reverse the list order */
        }

        .battle-log li {
            margin: 5px 0;
            line-height: 1.4;
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Battle container modifications */
        .battle-container {
            /* ...existing styles... */
            display: flex;
            flex-direction: column;
            min-height: auto; /* Remove vh-based height */
            gap: 10px; /* Add consistent spacing */
        }

        /* Battle controls positioning */
        .battle-controls {
            margin: 2rem 0;
            padding: 1rem;
            background: inherit;
            z-index: 10;
            position: relative; /* Change from sticky to relative */
        }

        /* Toast notification styles */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 9999; /* Ensure toasts are above everything */
            pointer-events: none; /* Prevent toast from blocking interactions */
        }

        .toast.error {
            background: rgba(231, 76, 60, 0.9);
        }

        /* Level up toast specific styles */
        .toast.level-up {
            background: rgba(241, 196, 15, 0.9); /* Yellow background for level up */
            bottom: 90px; /* Position above the regular toast */
            z-index: 10000; /* Higher than regular toast */
        }

        .toast.defeat {
            background: rgba(231, 76, 60, 0.95) !important; /* Red background for defeat */
        }

        /* Add these new styles */
        .victory-text {
            color: #2ecc71;
            font-size: 1.5em;
            margin: 1rem 0;
        }
        
        .defeat-text {
            color: #e74c3c;
            font-size: 1.5em;
            margin: 1rem 0;
        }

        /* Update the battle container image styles */
        .battle-container .monster .monster-image-container {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
        }

        .battle-container .monster .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                width: 100px;
                height: 100px;
            }
        }

        /* Update the battle container monster image styles */
        .battle-container .monster .monster-image-container,
        .battle-container .monster .monster-image-placeholder {
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .battle-container .monster .monster-image-container img {
            max-width: 150px;
            max-height: 150px;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                width: 100px;
                height: 100px;
            }

            .battle-container .monster .monster-image-container img {
                max-width: 100px;
                max-height: 100px;
            }
        }

        /* Fix battle container monster image sizing */
        .battle-container .monster {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            margin-bottom: 20px;
            gap: 1rem;
        }

        .battle-container .monster .monster-image-container {
            flex: 0 0 150px;  /* Fixed width, no growing or shrinking */
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .battle-container .monster .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .battle-container .monster .monster-image-placeholder {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                flex: 0 0 100px;
                width: 100px;
                height: 100px;
            }
        }

        /* Update battle container monster image styles */
        .battle-container .monster .monster-image-container {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0 1rem 0 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .battle-container .monster .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        .battle-container .monster .monster-image-placeholder {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container,
            .battle-container .monster .monster-image-placeholder {
                flex: 0 0 100px;
                width: 100px;
                height: 100px;
            }
        }

        /* Update preview monster image styles */
        .monster-preview .monster-image-container {
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0.5rem auto;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .monster-preview .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }

        /* Mobile adjustments */
        @media (max-width: 480px) {
            .monster-preview .monster-image-container {
                width: 120px;
                height: 120px;
            }
        }

        /* Add logo size control */
        .logo-container {
            width: 17.5%;  /* Changed from 35% to 17.5% */
            max-width: 150px;  /* Changed from 300px to 150px */
            margin: 0 auto 1rem auto; /* Reduced bottom margin from 2rem to 1rem */
        }

        .logo-container img {
            width: 100%;
            height: auto;
            display: block;
            object-fit: contain;
        }

        .monster-image-container {
            flex: 0 0 150px;
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            will-change: transform;
            transform: translateZ(0);
        }

        /* Enhanced mobile image stability */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                contain: strict;
                isolation: isolate;
                transform: translateZ(0);
                backface-visibility: hidden;
                perspective: 1000;
                -webkit-transform: translateZ(0);
                -webkit-backface-visibility: hidden;
                -webkit-perspective: 1000;
            }

            .battle-container .monster .monster-image-container img {
                contain: strict;
                transform: translateZ(0);
                backface-visibility: hidden;
                -webkit-transform: translateZ(0);
                -webkit-backface-visibility: hidden;
                image-rendering: -webkit-optimize-contrast;
                pointer-events: none;
            }
        }

        /* Update monster image container styles for better performance */
        .monster-image-container {
            contain: layout size;
            will-change: transform;
            transform: translate3d(0,0,0);
            backface-visibility: hidden;
            isolation: isolate;
            position: relative;
            width: 150px;
            height: 150px;
            margin: 0;
            flex: 0 0 150px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.1);
        }

        .monster-image-container img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            pointer-events: none;
            transform: translate3d(0,0,0);
            backface-visibility: hidden;
            -webkit-transform: translate3d(0,0,0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000px;
            perspective: 1000px;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
        }

        /* Mobile-specific optimizations */
        @media (max-width: 480px) {
            .battle-container .monster .monster-image-container {
                width: 100px;
                height: 100px;
                flex: 0 0 100px;
            }
        }

        /* Add optimized GPU acceleration styles */
        .monster-image-container {
            /* ...existing styles... */
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transform-style: preserve-3d;
            -webkit-transform-style: preserve-3d;
            isolation: isolate;
            contain: content;
        }

        .monster-image-container img {
            /* ...existing styles... */
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
            perspective: 1000;
        }

        /* iOS specific optimizations */
        @supports (-webkit-overflow-scrolling: touch) {
            .monster-image-container {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
            
            .monster-image-container img {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
            }
        }

        /* Add new stable image classes */
        .monster-image-stable {
            contain: layout size;
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            isolation: isolate;
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .monster-image-stable img {
            transform: translate3d(0,0,0);
            -webkit-transform: translate3d(0,0,0);
            will-change: transform;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        /* Add iOS-specific optimizations */
        @supports (-webkit-overflow-scrolling: touch) {
            .monster-image-stable {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                contain: strict;
            }
            
            .monster-image-stable img {
                transform: translateZ(0);
                -webkit-transform: translateZ(0);
                contain: strict;
            }
        }

        /* Fix iOS flicker on images */
        .monster-image-container img {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        /* Fix iOS flicker on player's monster image */
        .battle-container .monster .monster-image-container img {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        .start-battle-button, .nav-button.start-new-battle {
            background: linear-gradient(135deg, #3498db, #e74c3c); /* Blue to red gradient */
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .start-battle-button:hover, .nav-button.start-new-battle:hover {
            background: linear-gradient(135deg, #2980b9, #c0392b); /* Darker gradient on hover */
        }

        /* Add new animation keyframes */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px) rotate(-1deg); }
            75% { transform: translateX(5px) rotate(1deg); }
        }

        @keyframes heal-pulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px #2ecc71); }
            100% { filter: brightness(1); }
        }

        @keyframes damage-flash {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px #e74c3c); }
            100% { filter: brightness(1); }
        }

        @keyframes special-attack-glow {
            0% { filter: brightness(1); }
            50% { 
                filter: brightness(1.8) drop-shadow(0 0 15px #f39c12) 
                       drop-shadow(0 0 25px #e67e22);
            }
            100% { filter: brightness(1); }
        }

        /* Add these new utility classes */
        .shake-animation {
            animation: shake 0.5s ease-in-out;
        }

        .heal-animation {
            animation: heal-pulse 0.8s ease-in-out;
        }

        .damage-animation {
            animation: damage-flash 0.5s ease-in-out;
        }

        .special-attack-animation {
            animation: special-attack-glow 1s ease-in-out;
        }

        /* Ensure animations work on mobile */
        @media (prefers-reduced-motion: reduce) {
            .shake-animation,
            .heal-animation,
            .damage-animation,
            .special-attack-animation {
                animation: none;
            }
        }

        @keyframes defense-glow {
            0% { box-shadow: 0 0 5px 2px rgba(52, 152, 219, 0.4); }
            50% { box-shadow: 0 0 15px 5px rgba(52, 152, 219, 0.6); }
            100% { box-shadow: 0 0 5px 2px rgba(52, 152, 219, 0.4); }
        }

        .defending .monster-image-container {
            animation: defense-glow 2s ease-in-out infinite;
        }

        /* Add opponent-specific animation classes */
        .opponent-damage-animation {
            animation: damage-flash 0.5s ease-in-out !important;
        }

        .opponent-heal-animation {
            animation: heal-pulse 0.8s ease-in-out !important;
        }

        .opponent-defend-animation {
            animation: defense-glow 2s ease-in-out infinite !important;
        }

        .opponent-crit-animation {
            animation: special-attack-glow 1s ease-in-out !important;
        }

        /* Ensure animations work on both player and opponent containers */
        .battle-container .monster:last-child .monster-image-container.opponent-damage-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-heal-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-defend-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-crit-animation {
            animation-play-state: running !important;
            animation-fill-mode: both !important;
        }

        /* Add hardware acceleration for opponent container */
        .battle-container .monster:last-of-type {
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
        }

        /* Update opponent-specific animation classes */
        .battle-container .monster:last-child.opponent-damage-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-damage-animation {
            animation: damage-flash 0.5s ease-in-out !important;
        }

        .battle-container .monster:last-child.opponent-shake-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-shake-animation {
            animation: shake 0.5s ease-in-out !important;
        }

        .battle-container .monster:last-child .monster-image-container.special-attack-animation {
            animation: special-attack-glow 1s ease-in-out !important;
        }

        /* Add iOS-specific fixes */
        @supports (-webkit-touch-callout: none) {
            .battle-container .monster .monster-image-container {
                -webkit-transform: translate3d(0,0,0);
                transform: translate3d(0,0,0);
                -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
                -webkit-perspective: 1000;
                perspective: 1000;
                contain: paint;
            }

            .battle-container .monster .monster-image-container img {
                transform: none !important;
                -webkit-transform: none !important;
                animation: none !important;
                will-change: auto;
            }

            /* Move animations to the parent container instead */
            .battle-container .monster.shake-animation .monster-image-container,
            .battle-container .monster.opponent-shake-animation .monster-image-container {
                animation: shake 0.5s ease-in-out;
            }

            .battle-container .monster.damage-animation .monster-image-container,
            .battle-container .monster.opponent-damage-animation .monster-image-container {
                animation: damage-flash 0.5s ease-in-out;
            }
        }

        /* Update opponent animations to target the correct container */
        .battle-container .monster:last-child .monster-image-container.opponent-damage-animation {
            animation: damage-flash 0.5s ease-in-out;
        }

        .battle-container .monster:last-child .monster-image-container.opponent-shake-animation {
            animation: shake 0.5s ease-in-out;
        }

        .battle-container .monster:last-child .monster-image-container.special-attack-animation {
            animation: special-attack-glow 1s ease-in-out;
        }

        /* Update button colors */
        .battle-controls button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        /* Attack button - Red */
        .battle-controls button:nth-child(1) {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        .battle-controls button:nth-child(1):hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
        }

        /* Defend button - Blue (unchanged) */
        .battle-controls button:nth-child(2) {
            background: linear-gradient(135deg, #2c3e50, #3498db);
        }
        .battle-controls button:nth-child(2):hover {
            background: linear-gradient(135deg, #34495e, #2980b9);
        }

        /* Heal button - Green */
        .battle-controls button:nth-child(3) {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }
        .battle-controls button:nth-child(3):hover {
            background: linear-gradient(135deg, #219a52, #25a25a);
        }

        /* Fix iOS image flicker once and for all */
        @supports (-webkit-touch-callout: none) {
            .monster .monster-image-container {
                transform: translate3d(0,0,0);
                -webkit-transform: translate3d(0,0,0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
                perspective: 1000px;
                -webkit-perspective: 1000px;
                contain: strict;
                will-change: transform;
                isolation: isolate;
            }

            .monster .monster-image-container img {
                transform: translate3d(0,0,0);
                -webkit-transform: translate3d(0,0,0);
                backface-visibility: hidden;
                -webkit-backface-visibility: hidden;
                contain: strict;
                will-change: transform;
                pointer-events: none;
            }

            /* Prevent any transition/animation on the image itself */
            .monster .monster-image-container img {
                transition: none !important;
                animation: none !important;
            }
        }

        /* Ensure VFX work on both player and opponent */
        .monster-image-container {
            position: relative;
            transition: transform 0.3s ease;
        }

        /* Update animation selectors to target containers properly */
        .shake-animation, .opponent-shake-animation {
            animation: shake 0.5s ease-in-out !important;
        }

        .damage-animation, .opponent-damage-animation {
            animation: damage-flash 0.5s ease-in-out !important;
        }

        .heal-animation {
            animation: heal-pulse 0.8s ease-in-out !important;
        }

        .special-attack-animation {
            animation: special-attack-glow 1s ease-in-out !important;
        }

        /* Ensure animations work on both player and opponent containers */
        .battle-container .monster:last-child .monster-image-container.opponent-damage-animation,
        .battle-container .monster:last-child .monster-image-container.opponent-shake-animation,
        .battle-container .monster:last-child .monster-image-container.special-attack-animation {
            animation-play-state: running !important;
            animation-fill-mode: both !important;
        }

        /* Update opponent animation classes */
        .battle-container .monster:last-child .monster-image-container {
            transform: translate3d(0,0,0);
            will-change: transform;
        }

        .battle-container .monster:last-child.shake-animation,
        .battle-container .monster.last-child.opponent-shake-animation {
            animation: shake 0.5s ease-in-out !important;
        }

        .battle-container .monster:last-child .monster-image-container.damage-animation,
        .battle-container .monster.last-child .monster-image-container.opponent-damage-animation {
            animation: damage-flash 0.5s ease-in-out !important;
        }

        .battle-container .monster:last-child .monster-image-container.special-attack-animation {
            animation: special-attack-glow 1s ease-in-out !important;
        }

        /* New animations for health bar flashing (damage/heal) */
        @keyframes healthBarFlash {
            0% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.5) saturate(1.3); }
            100% { filter: brightness(1) saturate(1); }
        }

        /* Classes for player and opponent health bar VFX */
        .player-health-flash {
            animation: healthBarFlash 0.5s ease-in-out;
        }
        .opponent-health-flash {
            animation: healthBarFlash 0.5s ease-in-out;
        }

        /* Enhanced health bar flash animation */
        @keyframes healthBarFlash {
            0% { 
                filter: brightness(1) saturate(1);
                transform: scaleY(1);
            }
            50% { 
                filter: brightness(2) saturate(2);
                transform: scaleY(1.2);
            }
            100% { 
                filter: brightness(1) saturate(1);
                transform: scaleY(1);
            }
        }

        /* Enhanced shake animation */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px) rotate(-2deg); }
            75% { transform: translateX(10px) rotate(2deg); }
        }

        /* Enhanced heal pulse animation */
        @keyframes heal-pulse {
            0% { filter: brightness(1); }
            50% { 
                filter: brightness(2) drop-shadow(0 0 20px #2ecc71) 
                       drop-shadow(0 0 30px #27ae60);
            }
            100% { filter: brightness(1); }
        }

        /* Enhanced damage flash animation */
        @keyframes damage-flash {
            0% { filter: brightness(1); }
            50% { 
                filter: brightness(2) drop-shadow(0 0 20px #e74c3c) 
                       drop-shadow(0 0 30px #c0392b);
            }
            100% { filter: brightness(1); }
        }

        /* Enhanced special attack glow */
        @keyframes special-attack-glow {
            0% { filter: brightness(1); }
            50% { 
                filter: brightness(2.5) drop-shadow(0 0 25px #f39c12) 
                       drop-shadow(0 0 40px #e67e22);
            }
            100% { filter: brightness(1); }
        }

        /* Enhanced defense glow */
        @keyframes defense-glow {
            0% { box-shadow: 0 0 10px 5px rgba(52, 152, 219, 0.6); }
            50% { box-shadow: 0 0 25px 10px rgba(52, 152, 219, 0.8); }
            100% { box-shadow: 0 0 10px 5px rgba(52, 152, 219, 0.6); }
        }

        /* Make health bar effects more visible */
        .player-health-flash, .opponent-health-flash {
            animation: healthBarFlash 0.5s ease-in-out;
            transform-origin: center;
        }

        /* Update durations for more impactful animations */
        .shake-animation, .opponent-shake-animation {
            animation: shake 0.6s cubic-bezier(.36,.07,.19,.97) both !important;
        }

        .heal-animation {
            animation: heal-pulse 1s ease-in-out !important;
        }

        .damage-animation, .opponent-damage-animation {
            animation: damage-flash 0.7s ease-in-out !important;
        }

        .special-attack-animation {
            animation: special-attack-glow 1.2s ease-in-out !important;
        }

        /* Add these new styles for disabled battle controls */
        .battle-controls button[disabled] {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d) !important;
            cursor: not-allowed;
            opacity: 0.7;
            position: relative;
        }

        /* Update the battle controls container for better spacing */
        .battle-controls {
            margin: 2rem 0;
            padding: 1rem;
            white-space: nowrap;
            padding-bottom: 1.5rem; /* Add space for the disabled message */
        }

        /* Update battle log and controls spacing */
        .battle-log {
            height: 100px; /* Reduced from 120px */
            margin: 10px 0; /* Reduced from 20px */
        }

        .battle-controls {
            margin: 0.5rem 0; /* Reduced from 2rem */
            padding: 0.5rem; /* Reduced from 1rem */
        }

        /* Update victory/defeat section spacing */
        .victory-text, .defeat-text {
            margin: 0.5rem 0; /* Reduced from 1rem */
        }

        .battle-controls button {
            margin: 3px; /* Reduced from 5px */
        }

        /* Remove 3D transforms and aggressive will-change to reduce iOS flicker */
        .monster-image-container {
            /* ...existing code... */
            transform: none;
            -webkit-transform: none;
            will-change: auto;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        .monster-image-container img {
            /* ...existing code... */
            transform: none;
            -webkit-transform: none;
            will-change: auto;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }

        /* Ensure VFX also apply to the opponent monster */
        .monster.opponent .monster-image-container.shake-animation {
            animation: shake 0.5s ease-in-out;
        }
        .monster.opponent .monster-image-container.damage-animation {
            animation: damage-flash 0.5s ease-in-out;
        }

        .battle-container .monster.shake-animation .monster-image-container img {
            animation: shake 0.5s ease-in-out;
        }

        .battle-container .monster.heal-animation .monster-image-container img {
            animation: heal-pulse 0.8s ease-in-out;
        }

        .battle-container .monster.damage-animation .monster-image-container img {
            animation: damage-flash 0.5s ease-in-out;
        }

        .battle-container .monster.special-attack-animation .monster-image-container img {
            animation: special-attack-glow 1s ease-in-out;
        }

        /* Ensure opponent monster also applies animations */
        .battle-container .opponent-monster.shake-animation .monster-image-container img,
        .battle-container .opponent-monster.heal-animation .monster-image-container img,
        .battle-container .opponent-monster.damage-animation .monster-image-container img,
        .battle-container .opponent-monster.special-attack-animation .monster-image-container img {
            animation-duration: 0.8s; /* matching your existing durations */
            animation-timing-function: ease-in-out;
        }

        /* Consolidated monster-image-container styling */
        .monster-image-container {
            width: 150px;
            height: 150px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            transform: none;
            contain: none;
        }

        .monster-image-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
            pointer-events: none;
            transform: none;
        }

        @supports (-webkit-overflow-scrolling: touch) {
            .monster-image-container,
            .monster-image-container img {
                transform: none !important;
                contain: none !important;
            }
        }

        /* Animations target the container only */
        .shake-animation { animation: shake 0.5s ease-in-out; }
        .heal-animation { animation: heal-pulse 0.8s ease-in-out; }
        .damage-animation { animation: damage-flash 0.5s ease-in-out; }
        .special-attack-animation { animation: special-attack-glow 0.8s ease-in-out; }

        /* Update battle controls container for better centering */
        .battle-controls {
            margin: 0.5rem 0;
            padding: 0.5rem;
            text-align: center; /* Add this */
        }

        .battle-controls > div {
            display: flex;
            flex-direction: column;
            align-items: center; /* Add this */
        }

        .battle-controls > div > div {
            display: flex;
            flex-wrap: wrap;
            justify-content: center; /* Add this */
            gap: 5px; /* Add this for consistent spacing */
            width: 100%; /* Add this */
            max-width: 600px; /* Add this to prevent too wide on large screens */
        }

        /* Adjust button margins for better spacing */
        .battle-controls button {
            margin: 1px;
            flex: 0 1 auto; /* Add this to prevent button stretching */
            min-width: 80px; /* Add this to maintain minimum button width */
        }

        /* Update battle log styles for better readability */
        .battle-log li.victory-message {
            color: #2ecc71;
            font-weight: bold;
            font-size: larger; /* Increased font size */
        }

        .battle-log li.defeat-message {
            color: #e74c3c;
            font-weight: bold;
            font-size: larger; /* Increased font size */
        }

        .xp-gain {
            color: #000; /* Change to black */
        }
        .level-up {
            color: #000; /* Change to black */
        }
    </style>
</head>
<body>
    <button id="darkModeToggle" class="dark-mode-toggle">ðŸŒ™</button>

    <div class="battle-container">
        <div class="logo-container">
        </div>

        <!-- Add battle preview section -->
        <div id="battlePreview" class="battle-preview">
            <div class="versus-display">
                <div class="monster-preview">
                    <h3 id="playerMonsterName">Your Monster</h3>
                    <div id="playerMonsterImage">
                        <!-- Image container will be dynamically inserted here -->
                    </div>
                    <p id="playerMonsterStats">Loading stats...</p>
                </div>
                <div class="versus-text">VS</div>
                <div class="monster-preview">
                    <h3>AI Monster</h3>
                    <div class="monster-image-placeholder"></div>
                    <p>Loading...</p>
                </div>
            </div>
            <button class="nav-button start-battle-button" onclick="startBattle()">Start Battle</button>
        </div>

        <div id="root"></div>

        <!-- Hide this back to profile button once battle starts -->
        <div class="navigation-grid" style="margin-top: 2rem;">
            <button class="nav-button" onclick="location.href='monster-collection.html'">Back to Profile</button>
        </div>

        <footer>
            <p>Version: <span id="versionNumber">1.0.0564</span></p>
            <p>&copy; 2025 Barcode Masters | <a href="changelog.html">Change Log</a> | <a href="privacy-policy.html">Privacy Policy</a></p>
        </footer>
    </div>

    <script type="text/babel">
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDoIWAIUt4HC1RcNmdfXozEr0NG65GO63s",
            authDomain: "barcodemasters-b4b9b.firebaseapp.com",
            projectId: "barcodemasters-b4b9b",
            storageBucket: "barcodemasters-b4b9b.firebasestorage.app",
            messagingSenderId: "827677074735",
            appId: "1:827677074735:web:3bace3d02034348bc82dda"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth(); // Add this line
        const storage = firebase.storage(); // Add this line

        // Add this function before the BattleSystem component and updatePreview function
        const getMonsterImageHTML = (monster) => {
            if (!monster?.imageUrl) {
                return `<div class="monster-image-placeholder"></div>`;
            }
            
            return `
                <div class="monster-image-container">
                    <img src="${monster.imageUrl}" 
                        alt="${monster.monsterName}" 
                        onerror='this.onerror=null;this.parentElement.innerHTML="<div class=\"monster-image-placeholder\"></div>"' 
                    />
                </div>`;
        };

        // Update the getRandomAIOpponentImage function
        async function getRandomAIOpponentImage() {
            // Check if we already have an image URL stored
            const storedUrl = sessionStorage.getItem('aiOpponentImage');
            if (storedUrl) {
                return storedUrl;
            }

            try {
                const totalImages = 12;
                const randomNumber = Math.floor(Math.random() * totalImages) + 1;
                const paddedNumber = String(randomNumber).padStart(2, '0');
                const imagePath = `robotAiOpponent-images/robotAiOpponent_${paddedNumber}.png`;
                
                const imageRef = storage.ref().child(imagePath);
                const url = await imageRef.getDownloadURL();
                
                // Store the URL in sessionStorage
                sessionStorage.setItem('aiOpponentImage', url);
                return url;
            } catch (error) {
                console.error('Error getting AI opponent image:', error);
                return null;
            }
        }

        // Update the calculateAILevel function
        function calculateAILevel(playerLevel) {
            // Generate a random number between 0 and 2 (inclusive) instead of 0 to 3
            const levelBonus = Math.floor(Math.random() * 3);  // 0 to 2
            // AI will be equal to player level or up to 2 levels higher
            return playerLevel + levelBonus;
        }

        const calculateXPProgress = (currentExp, level) => {
            const currentLevelTotalXP = monsterStats.calculateTotalXPToLevel(level);
            const nextLevelTotalXP = currentLevelTotalXP + monsterStats.calculateXPForNextLevel(level);
            const progress = ((currentExp - currentLevelTotalXP) / (nextLevelTotalXP - currentLevelTotalXP)) * 100;
            return Math.min(100, Math.max(0, progress));
        };

        // Simplified MonsterImage component
        const MonsterImage = React.memo(({ monster, isAI = false }) => {
    const imageUrl = isAI ? monster?.aiImageUrl : monster?.imageUrl;
    const containerRef = React.useRef(null);
    const imageRef = React.useRef(null);

    return (
        <div 
            ref={containerRef}
            className="monster-image-container"
        >
            {imageUrl && (
                <img 
                    ref={imageRef}
                    src={imageUrl}
                    alt={isAI ? 'AI Opponent' : monster?.monsterName}
                    loading="eager"
                    decoding="sync"
                />
            )}
        </div>
    );
}, (prev, next) => {
    // More strict comparison
    return (prev.monster?.imageUrl === next.monster?.imageUrl &&
            prev.isAI === next.isAI);
});
         (prevProps, nextProps) => {
            // Prevent re-render if the image URL hasn't changed
            return prevProps.monster?.imageUrl === nextProps.monster?.imageUrl &&
                   prevProps.isAI === nextProps.isAI;
        };

        const BattleSystem = () => {
            // Add isDefending state
            const [isDefending, setIsDefending] = React.useState(false);
            
            const [playerMonster, setPlayerMonster] = React.useState(null);
            const [opponentMonster, setOpponentMonster] = React.useState(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const playerLevel = parseInt(urlParams.get('level')) || 1;
                const opponentLevel = parseInt(sessionStorage.getItem('aiOpponentLevel')) || playerLevel;
                
                // Balanced base stats for AI
                const baseHP = 25;  // Decreased from 25 to 20
                const baseAP = 5;   // Decreased from 6 to 5
                const baseSpeed = 5; // Decreased from 6 to 5
                
                // Slightly reduced scaling factors
                const hpScaling = 0.40;  // Decreased from 0.45 to 0.40
                const apScaling = 0.20;  // Decreased from 0.25 to 0.20
                const speedScaling = 0.15; // Decreased from 0.20 to 0.15
                
                // Keep same level multiplier
                const levelMultiplier = opponentLevel > 3 ? 1 + ((opponentLevel - 3) * 0.1) : 1;
                
                const scaledHP = Math.round((baseHP * (1 + (opponentLevel - 1) * hpScaling)) * levelMultiplier);
                const scaledAP = Math.round((baseAP * (1 + (opponentLevel - 1) * apScaling)) * levelMultiplier);
                const scaledSpeed = Math.round((baseSpeed * (1 + (opponentLevel - 1) * speedScaling)) * levelMultiplier);
                
                return {
                    monsterName: `Level ${opponentLevel} AI Monster`,
                    type: "Robot",
                    level: opponentLevel,
                    HP: scaledHP,
                    AP: scaledAP,
                    Speed: scaledSpeed
                };
            });

            const [playerHealth, setPlayerHealth] = React.useState(100);
            const [opponentHealth, setOpponentHealth] = React.useState(opponentMonster.HP); // Also update initial health to match max HP
            const [battleLog, setBattleLog] = React.useState([]);
            const [isBattleOver, setIsBattleOver] = React.useState(false);
            const [isPlayerTurn, setIsPlayerTurn] = React.useState(true);
            const [battleState, setBattleState] = React.useState('ongoing'); // 'ongoing', 'victory', 'defeat'
            const [aiImageUrl, setAiImageUrl] = React.useState(null); // Add state for AI image

            // Add username state
            const [username, setUsername] = React.useState("Player");
    
            // Add useEffect to fetch username
            React.useEffect(() => {
                const fetchUsername = async () => {
                    try {
                        const user = auth.currentUser;
                        if (user) {
                            const userDoc = await db.collection('users').doc(user.uid).get();
                            if (userDoc.exists) {
                                setUsername(userDoc.data().username || "Player");
                            }
                        }
                    } catch (error) {
                        console.error("Error fetching username:", error);
                    }
                };
                fetchUsername();
            }, []);

            // Fetch player monster from URL
            React.useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                const monsterId = urlParams.get('id');
                
                if (monsterId) {
                    fetchMonsterData(monsterId).then(monsterData => {
                        if (monsterData) {
                            setPlayerMonster(monsterData);
                            setPlayerHealth(monsterData.HP);
                        }
                    });
                }
            }, []);

            // Update the useEffect for AI image
            React.useEffect(() => {
                // Get the stored image URL instead of generating a new one
                const storedUrl = sessionStorage.getItem('aiOpponentImage');
                if (storedUrl) {
                    setAiImageUrl(storedUrl);
                }
            }, []);

            // Main battle cycle (player turn / opponent turn)
            React.useEffect(() => {
                if (!isPlayerTurn && !isBattleOver && opponentHealth > 0) {
                    // Simple timeout for AI turn
                    const actionTimer = setTimeout(() => {
                        opponentTurn();
                    }, Math.floor(Math.random() * 2000) + 1000); // Random delay between 1-3 seconds

                    return () => {
                        clearTimeout(actionTimer);
                    };
                }
            }, [isPlayerTurn, isBattleOver, opponentHealth]);

            // Add messages to battle log
            const addToLog = (message) => {
                let emoji = '';
                if (message.includes('dealt')) {
                    emoji = 'ðŸ’ª '; // Note the space after emoji
                } else if (message.includes('Critical Hit')) {
                    emoji = 'ðŸ’¥ ';
                } else if (message.includes('healed')) {
                    emoji = 'â¤ï¸ ';
                } else if (message.includes('won')) {
                    emoji = 'ðŸ† ';
                } else if (message.includes('lost')) {
                    emoji = 'âŒ ';
                } else if (message.includes('defending')) {
                    emoji = 'ðŸ›¡ï¸ ';
                }
                // Keep more messages in the log (increased from 5 to 8)
                setBattleLog(prevLog => {
                    const newLog = [`${emoji}${message}`, ...prevLog].slice(0, 8);
                    return newLog;
                });
            };

            // Add an effect to show turn indicators
            React.useEffect(() => {
                if (!isBattleOver) {
                    // Clear previous turn messages when turn changes
                    const turnMessage = isPlayerTurn ? 
                        "ðŸŽ¯ Your turn..." : 
                        "ðŸ¤– Opponent's turn...";
                    addToLog(turnMessage);
                }
            }, [isPlayerTurn, isBattleOver]);

            // Check for win/loss conditions
            const checkBattleOutcome = () => {
                if (opponentHealth <= 0 && !isBattleOver) {
                    handleVictory();
                } else if (playerHealth <= 0 && !isBattleOver) {
                    handleDefeat();
                }
            };

            // Player action handlers
            // Update the damage calculation functions
            const calculateDamage = (attacker, isPlayer = true) => {
                const baseAP = Math.max(1, parseInt(attacker.AP) || 1);
                const variance = Math.floor((Math.random() * 0.3 - 0.15) * baseAP); // Increased variance
                
                // base damage for player
                let damage = isPlayer ? 
                    baseAP * 1.00 + variance : // Player deals 85% of AP
                    baseAP + variance;         // AI deals full AP
                
                // Ensure minimum damage
                damage = Math.max(1, Math.floor(damage));
                
                // Critical hit chances
                const criticalChance = isPlayer ? 0.1 : 0.15; // AI has higher crit chance
                const criticalMultiplier = isPlayer ? 1.5 : 1.75; // AI crits hit harder
                
                if (Math.random() < criticalChance) {
                    damage = Math.floor(damage * criticalMultiplier);
                    return { damage, isCritical: true };
                }
                
                return { damage, isCritical: false };
            };

            // HandleAttack function with updated damage calculation
            const handleAttack = async () => {
                if (isBattleOver || !isPlayerTurn) return;
    
                const { damage, isCritical } = calculateDamage(activeMonster, true);
                const newHealth = Math.max(0, opponentHealth - damage);
    
                // Get both the opponent container and image
                const opponentContainer = document.querySelector('.battle-container .monster:last-child');
                const opponentImage = opponentContainer?.querySelector('.monster-image-container');
    
                if (opponentContainer && opponentImage) {
                    // Clear any existing animations
                    opponentContainer.classList.remove('shake-animation', 'opponent-shake-animation');
                    opponentImage.classList.remove('damage-animation', 'opponent-damage-animation', 'special-attack-animation');
                    
                    // Force reflow
                    void opponentContainer.offsetWidth;
                    void opponentImage.offsetWidth;
                    
                    // Apply new animations
                    opponentContainer.classList.add(isCritical ? 'shake-animation' : 'opponent-shake-animation');
                    opponentImage.classList.add(isCritical ? 'special-attack-animation' : 'opponent-damage-animation');
                    
                    // Remove animations after they complete
                    setTimeout(() => {
                        opponentContainer.classList.remove('shake-animation', 'opponent-shake-animation');
                        opponentImage.classList.remove('damage-animation', 'opponent-damage-animation', 'special-attack-animation');
                    }, isCritical ? 1000 : 500);
                }
    
                setOpponentHealth(newHealth);
                addToLog(`You dealt ${damage} damage!${isCritical ? ' (Critical Hit!)' : ''}`);
                setIsPlayerTurn(false);
    
                if (newHealth <= 0) {
                    await handleVictory();
                    setIsBattleOver(true);
                }
            };

            // Add the victory handler
            const handleVictory = async () => {
                console.log('Starting victory handler with:', {
                    playerMonster,
                    isBattleOver,
                    opponentHealth
                });
                
                // Add check for valid monster data
                if (!playerMonster?.id) {
                    console.log('No valid monster ID found:', playerMonster);
                    return;
                }
                
                if (isBattleOver) {
                    console.log('Battle already over, stopping victory handler');
                    return;
                }

                console.log('Processing victory...');
                setBattleState('victory');
                setIsBattleOver(true);
                setOpponentHealth(0);

                try {
                    // Calculate XP gain with improved exponential scaling
                    const baseXP = 20 * Math.pow(1.2, Math.max(0, opponentMonster.level - 5)); // Exponential base scaling
                    const levelDifference = opponentMonster.level - playerMonster.level;
                    
                    // More generous level difference bonus
                    const levelBonus = Math.floor(baseXP * (levelDifference > 0 ? levelDifference * 0.85 : 0));
                    
                    // Improved exponential scaling - more generous at higher levels
                    const levelScaling = Math.pow(1.25, opponentMonster.level - 1); // Increased from 1.15 to 1.25
                    const scaledBaseXP = Math.floor(baseXP * levelScaling);
                    const randomBonus = Math.floor(Math.random() * (baseXP * 0.2)); // Random bonus scales with base XP
                    const totalExp = scaledBaseXP + levelBonus + randomBonus;

                    console.log('Victory XP calculation:', {
                        baseXP,
                        levelDifference,
                        levelScaling,
                        levelBonus,
                        scaledBaseXP,
                        randomBonus,
                        totalExp
                    });

                    // Update battle log and show toast
                    addToLog(`ðŸ† Victory! Earned ${totalExp} XP!`);
                    const randomVictoryMessage = victoryMessages[Math.floor(Math.random() * victoryMessages.length)]
                        .replace('{username}', username)
                        .replace('{xp}', totalExp);
                    showToast(`${randomVictoryMessage}\nGained <span style='color: black'>${totalExp} XP! ðŸŽ‰</span>`);

                    // Get current monster data
                    const monsterRef = db.collection('monsters').doc(playerMonster.id);
                    const doc = await monsterRef.get();
                    
                    if (!doc.exists) {
                        throw new Error('Monster document not found');
                    }

                    // Parse current values
                    const currentExp = parseInt(doc.data().experience) || 0;
                    const currentLevel = parseInt(doc.data().level) || 1;
                    const newExp = currentExp + totalExp;

                    console.log('Experience update:', { 
                        currentExp, 
                        totalExp, 
                        newExp, 
                        currentLevel,
                        nextLevelRequirement: monsterStats.calculateTotalXPToLevel(currentLevel + 1)
                    });

                    const updates = { experience: newExp };

                    // Check for level up using monsterStats function
                    if (monsterStats.canLevelUp(currentLevel, newExp)) {
                        const newLevel = currentLevel + 1;
                        updates.level = newLevel;
                        updates.HP = Math.round(doc.data().HP * 1.2);
                        updates.AP = Math.round(doc.data().AP * 1.15);
                        updates.Speed = Math.round(doc.data().Speed * 1.1);

                        console.log('Level up detected:', updates);

                        setTimeout(() => {
                            const randomLevelUpMessage = levelUpMessages[Math.floor(Math.random() * levelUpMessages.length)]
                                .replace('{monsterName}', playerMonster.monsterName)
                                .replace('{level}', updates.level);
                            showToast(randomLevelUpMessage, true);
                            addToLog(`ðŸŒŸ Level Up! ${playerMonster.monsterName} is now level ${newLevel}!`);
                        }, 1500);
                    }

                    // Update Firestore
                    console.log('Updating Firestore with:', updates);
                    await monsterRef.update(updates);
                    console.log('Firestore update successful');

                    // Update local state
                    setPlayerMonster(prev => ({
                        ...prev,
                        experience: newExp,
                        level: updates.level || prev.level,
                        HP: updates.HP || prev.HP,
                        AP: updates.AP || prev.AP,
                        Speed: updates.Speed || prev.Speed
                    }));

                } catch (error) {
                    console.error('Victory processing error:', error);
                    showToast('Error processing victory rewards! âŒ', false);
                    addToLog('âŒ Error processing victory rewards');
                }
            };

            // Update handleDefend function
            const handleDefend = () => {
                setIsDefending(true);
                addToLog("You're defending against the next attack! (Damage will be halved)");
                
                const playerElement = document.querySelector('.battle-container .monster:first-of-type');
                if (playerElement) {
                    playerElement.classList.add('defending');
                    // Don't remove the defense animation here - it will be removed after the next attack or turn
                }
                
                setIsPlayerTurn(false);
            };

            // Update handleHeal function with percentage-based healing
            const handleHeal = () => {
                // Healing scales with level and gets less effective at higher HP
                const baseHealPercent = 0.42; // Heal player amount
                const currentHPPercent = playerHealth / activeMonster.HP;
                const healEffectiveness = 1 - (currentHPPercent * 0.5); // Reduced healing at higher HP
                
                const healAmount = Math.floor(
                    activeMonster.HP * baseHealPercent * healEffectiveness
                );
                
                // Add visual effect
                const playerElement = document.querySelector('.battle-container .monster:first-of-type');
                if (playerElement) {
                    playerElement.classList.add('heal-animation');
                    setTimeout(() => {
                        playerElement.classList.remove('heal-animation');
                    }, 800);
                }
                
                setPlayerHealth(prev => {
                    const newHealth = Math.min(parseInt(activeMonster.HP), prev + healAmount);
                    addToLog(`You healed for ${newHealth - prev} HP!`);
                    return newHealth;
                });
                setIsPlayerTurn(false);
            };

            // Opponent AI behavior
            // Update opponentTurn with smarter AI behavior
            const opponentTurn = async () => {
                if (isBattleOver || isPlayerTurn || playerHealth <= 0) return;

                // Add delay before opponent's action
                await new Promise(resolve => setTimeout(resolve, 1000));

                // AI decision making based on health percentage
                const aiHealthPercentage = opponentHealth / opponentMonster.HP;
                const playerHealthPercentage = playerHealth / activeMonster.HP;

                // Choose action based on situation
                let action = 'attack'; // Default action

                if (aiHealthPercentage < 0.3) {
                    // When critically low on health
                    const random = Math.random();
                    if (random < 0.6) { // 60% chance to heal when critical
                        action = 'heal';
                    } else if (random < 0.9) { // 30% chance to defend
                        action = 'defend';
                    }
                    // 10% chance to still attack
                } else if (aiHealthPercentage < 0.5) {
                    // When moderately low on health
                    const random = Math.random();
                    if (random < 0.4) { // 40% chance to heal
                        action = 'heal';
                    } else if (random < 0.3) { // 30% chance to defend
                        action = 'defend';
                    }
                    // 30% chance to attack
                } else if (playerHealthPercentage < 0.3 && aiHealthPercentage > 0.6) {
                    // Aggressive when player is low and AI is healthy
                    const random = Math.random();
                    if (random < 0.8) { // 80% chance to attack
                        action = 'attack';
                    } else { // 20% chance to defend
                        action = 'defend';
                    }
                }

                // Execute the chosen action
                const opponentContainer = document.querySelector('.battle-container .monster:last-child');
                const opponentImage = opponentContainer?.querySelector('.monster-image-container');
                const playerContainer = document.querySelector('.battle-container .monster:first-child');
                const playerImage = playerContainer?.querySelector('.monster-image-container');

                // Clear any existing animations
                if (opponentImage) {
                    opponentImage.classList.remove('opponent-heal-animation', 'opponent-defend-animation', 'opponent-damage-animation', 'opponent-crit-animation');
                    void opponentImage.offsetWidth;
                }

                switch (action) {
                    case 'heal':
                        const healPercent = 0.3; // Heal 30% of max HP
                        const healAmount = Math.floor(opponentMonster.HP * healPercent);
                        const newHealth = Math.min(opponentMonster.HP, opponentHealth + healAmount);
                        setOpponentHealth(newHealth);
                        addToLog(`Opponent healed for ${newHealth - opponentHealth} HP!`);
                        
                        // Add visual effect
                        if (opponentImage) {
                            opponentImage.classList.add('opponent-heal-animation');
                            setTimeout(() => {
                                opponentImage.classList.remove('opponent-heal-animation');
                            }, 800);
                        }
                        break;

                    case 'defend':
                        if (opponentImage) {
                            opponentImage.classList.add('opponent-defend-animation');
                        }
                        addToLog("Opponent is defending against the next attack!");
                        window.aiDefending = true;
                        break;

                    default: // Attack
                        const { damage, isCritical } = calculateDamage(opponentMonster, false);
                        let finalDamage = isDefending ? Math.floor(damage / 1.75) : damage;
                        
                        // Remove defense effect after taking damage
                        const defendingPlayer = document.querySelector('.battle-container .monster:first-of-type');
                        if (defendingPlayer) {
                            defendingPlayer.classList.remove('defending');
                        }
                        
                        // Apply visual effects to player monster
                        if (defendingPlayer) {
                            defendingPlayer.classList.add('shake-animation', 'damage-animation');
                            setTimeout(() => {
                                defendingPlayer.classList.remove('shake-animation', 'damage-animation');
                            }, 500);
                        }
                        
                        if (playerHealthPercentage < 0.3) {
                            finalDamage = Math.floor(finalDamage * 1.2); // 20% bonus damage on low HP targets
                        }

                        const newPlayerHealth = Math.max(0, playerHealth - finalDamage);
                        setPlayerHealth(newPlayerHealth);
                        
                        const message = isDefending 
                            ? `Opponent dealt ${finalDamage} damage! (Reduced by defense)` 
                            : playerHealthPercentage < 0.3 
                                ? `Opponent dealt ${finalDamage} damage! (Execution bonus)`
                                : `Opponent dealt ${finalDamage} damage!${isCritical ? ' (Critical Hit!)' : ''}`;
                        
                        addToLog(message);

                        // Add visual effect for opponent attacks
                        const playerElement = document.querySelector('.battle-container .monster:first-child');
                        if (playerElement) {
                            playerElement.classList.remove('shake-animation', 'damage-animation');
                            void playerElement.offsetWidth;
                            playerElement.classList.add('shake-animation', 'damage-animation');
                            setTimeout(() => {
                                playerElement.classList.remove('shake-animation', 'damage-animation');
                            }, 500);
                        }

                        if (newPlayerHealth <= 0) {
                            setIsBattleOver(true);
                            await handleDefeat();
                            return;
                        }
                        break;
                }

                setIsDefending(false);
                // Add small delay before setting player turn
                setTimeout(() => {
                    setIsPlayerTurn(true);
                }, 500);

                // Remove opponent defense at end of their turn
                const defendingOpponent = document.querySelector('.battle-container .monster:nth-of-type(2)');
                if (defendingOpponent && defendingOpponent.classList.contains('defending')) {
                    defendingOpponent.classList.remove('defending');
                }
            };

            // Add the defeat handler
            const handleDefeat = async () => {
                if (!playerMonster?.id || isBattleOver) return;

                setBattleState('defeat');
                setIsBattleOver(true);
                setPlayerHealth(0);

                try {
                    const currentExp = parseInt(playerMonster.experience) || 0;
                    const currentLevel = parseInt(playerMonster.level) || 1;
                    
                    const minXpForCurrentLevel = monsterStats.calculateTotalXPToLevel(currentLevel);
                    const xpAboveThreshold = Math.max(0, currentExp - minXpForCurrentLevel);
                    const xpLoss = Math.floor(xpAboveThreshold * 0.1);
                    const newExp = Math.max(minXpForCurrentLevel, currentExp - xpLoss);
                    const actualXpLost = currentExp - newExp;

                    // Only show XP loss in messages if there was actual XP lost
                    if (actualXpLost > 0) {
                        addToLog(`ðŸ’€ Defeat! Lost ${actualXpLost} XP!`);
                        const randomDefeatMessage = defeatMessages[Math.floor(Math.random() * defeatMessages.length)]
                            .replace('{username}', username);
                        showToast(randomDefeatMessage, false, true);
                    } else {
                        addToLog(`ðŸ’€ Defeat!`);
                        showToast(`Defeat! âŒ`, false, true);
                    }

                    if (actualXpLost > 0) {
                        const monsterRef = db.collection('monsters').doc(playerMonster.id);
                        await monsterRef.update({ experience: newExp });
                        setPlayerMonster(prev => ({
                            ...prev,
                            experience: newExp
                        }));
                    }

                } catch (error) {
                    console.error('Defeat processing error:', error);
                    addToLog('âŒ Error processing defeat penalties');
                }
            };

            const activeMonster = playerMonster || {
                monsterName: "Player Monster",
                type: "Fighter",
                level: 1,
                HP: 100,
                AP: 10,
                Speed: 10
            };

            // Add new function to update monster experience
            const updateMonsterExperience = async (monsterId, expChange) => {
                console.log(`Starting experience update for monster ${monsterId} by ${expChange}`);
                
                try {
                    const monsterRef = db.collection('monsters').doc(monsterId);
                    const monsterDoc = await monsterRef.get();
                    
                    if (!monsterDoc.exists) {
                        console.error('Monster document not found');
                        throw new Error('Monster not found in database');
                    }

                    const monsterData = monsterDoc.data();
                    console.log('Current monster data:', monsterData);

                    // Ensure numeric values
                    const currentExp = parseInt(monsterData.experience) || 0;
                    const currentLevel = parseInt(monsterData.level) || 1;
                    const newExp = Math.max(0, currentExp + expChange);
                    
                    console.log(`Experience: ${currentExp} -> ${newExp}`);

                    const updates = {
                        experience: newExp
                    };

                    // Check for level up
                    if (expChange > 0) {
                        const expForNextLevel = currentLevel * 100;
                        console.log(`Exp needed for next level: ${expForNextLevel}`);
                        
                        if (newExp >= expForNextLevel) {
                            const newLevel = currentLevel + 1;
                            console.log(`Level up! ${currentLevel} -> ${newLevel}`);
                            
                            // Get base stats
                            const baseHP = parseInt(monsterData.HP) || 10;
                            const baseAP = parseInt(monsterData.AP) || 5;
                            const baseSpeed = parseInt(monsterData.Speed) || 5;

                            // Calculate new stats with level multipliers
                            updates.level = newLevel;
                            updates.HP = Math.round(baseHP * (1 + (newLevel - 1) * 0.2));
                            updates.AP = Math.round(baseAP * (1 + (newLevel - 1) * 0.15));
                            updates.Speed = Math.round(baseSpeed * (1 + (newLevel - 1) * 0.1));

                            console.log('New stats after level up:', updates);
                        }
                    }

                    console.log('Applying updates to database:', updates);
                    await monsterRef.update(updates);
                    console.log('Database update successful');

                    return {
                        success: true,
                        levelUp: updates.level !== undefined,
                        newLevel: updates.level || currentLevel,
                        expChange,
                        newExp,
                        newStats: {
                            HP: updates.HP,
                            AP: updates.AP,
                            Speed: updates.Speed
                        }
                    };

                } catch (error) {
                    console.error('Error in updateMonsterExperience:', error);
                    throw error;
                }
            };

            // Add this function to generate monster image HTML
            const getMonsterImageHTML = (monster) => {
                if (!monster?.imageUrl) {
                    return `<div class="monster-image-placeholder"></div>`;
                }
                
                return `
                    <div class="monster-image-container">
                        <img src="${monster.imageUrl}" 
                            alt="${monster.monsterName}" 
                            onerror='this.onerror=null;this.parentElement.innerHTML="<div class=\"monster-image-placeholder\"></div>"' 
                        />
                    </div>`;
            };

            // Add helper function to generate image content
            const MonsterImage = React.memo(({ monster, isAI = false }) => {
                const imageUrl = React.useMemo(() => isAI ? aiImageUrl : monster?.imageUrl, [isAI, aiImageUrl, monster?.imageUrl]);
                const containerRef = React.useRef(null);
                
                React.useEffect(() => {
                    if (containerRef.current) {
                        containerRef.current.style.transform = 'translateZ(0)';
                    }
                }, []);

                return (
                    <div 
                        ref={containerRef}
                        className="monster-image-container"
                        style={{
                            contain: 'strict',
                            willChange: 'transform',
                            transform: 'translateZ(0)',
                            WebkitTransform: 'translateZ(0)'
                        }}
                    >
                        {imageUrl ? (
                            <img 
                                src={imageUrl}
                                alt={isAI ? 'AI Opponent' : monster?.monsterName}
                                loading="eager"
                                decoding="sync"
                                style={{
                                    width: '100%',
                                    height: '100%',
                                    objectFit: 'contain',
                                    transform: 'translateZ(0)',
                                    WebkitTransform: 'translateZ(0)',
                                    willChange: 'transform'
                                }}
                            />
                        ) : (
                            <div className="monster-image-placeholder" />
                        )}
                    </div>
                );
            }, (prev, next) => prev.monster?.imageUrl === next.monster?.imageUrl && prev.isAI === next.isAI);

            // Add showToast function
            const showToast = (message, isLevelUp = false, isDefeat = false) => {
                console.log('showToast called:', { message, isLevelUp, isDefeat }); // Debug log
                
                const toastId = isLevelUp ? 'levelUpToast' : 'battleToast';
                let toast = document.getElementById(toastId);
                
                // Remove existing toast
                if (toast) {
                    console.log('Removing existing toast:', toastId);
                    toast.remove();
                }
                
                // Create new toast
                toast = document.createElement('div');
                toast.id = toastId;
                toast.className = `toast${isLevelUp ? ' level-up' : ''}${isDefeat ? ' defeat' : ''}`;
                toast.innerHTML = message; // Use innerHTML to handle HTML content
                
                console.log('Creating new toast:', { id: toastId, message }); // Debug log
                document.body.appendChild(toast);
                
                // Force reflow and add debug logging
                void toast.offsetWidth;
                console.log('Toast element:', toast);
                console.log('Toast styles:', window.getComputedStyle(toast));
                
                // Show toast with debugging
                requestAnimationFrame(() => {
                    toast.style.transform = 'translateY(0)';
                    toast.style.opacity = '1';
                    console.log('Toast animation started');
                });

                // Hide and remove toast after toasttimer delay
                setTimeout(() => {
                    console.log('Starting toast removal animation');
                    toast.style.transform = 'translateY(100px)';
                    toast.style.opacity = '0';
                    
                    setTimeout(() => {
                        if (toast.parentElement) {
                            toast.parentElement.removeChild(toast);
                            console.log('Toast removed from DOM');
                        }
                    }, 300);
                }, 10000); // Increased duration to 10 seconds
            };

            // Add calculateBattleRewards function
            function calculateBattleRewards() {
                // 
                const baseXP = 8;
                // Keep mild level bonus but reduce it to prevent exponential growth
                const levelDifference = opponentMonster.level - playerMonster.level;
                let levelBonus = 0;
                if (levelDifference > 0) {
                    // Reduced from 0.5 to 0.25
                    levelBonus = levelDifference * 0.25;
                }
                const totalExp = Math.floor(baseXP + (baseXP * levelBonus));

                
            }

            // Add this useEffect inside the component
            React.useEffect(() => {
                if (!isBattleOver) {
                    if (opponentHealth <= 0) {
                        handleVictory();
                    } else if (playerHealth <= 0) {
                        handleDefeat();
                    }
                }
            }, [opponentHealth, playerHealth]);

            // Add new state for special attack cooldown
            const [specialCooldown, setSpecialCooldown] = React.useState(3);

            // Add special attack handler
            const handleSpecialAttack = async () => {
                if (isBattleOver || !isPlayerTurn || specialCooldown > 0) return;

                const specialDamage = Math.floor(calculateDamage(activeMonster, true).damage * 2.5);
                const newHealth = Math.max(0, opponentHealth - specialDamage);

                const opponentElement = document.querySelector('.battle-container .monster:last-child .monster-image-container');
                if (opponentElement) {
                    opponentElement.classList.remove('opponent-shake-animation', 'special-attack-animation');
                    void opponentElement.offsetWidth;
                    opponentElement.classList.add('opponent-shake-animation', 'special-attack-animation');
                    setTimeout(() => {
                        opponentElement.classList.remove('opponent-shake-animation', 'special-attack-animation');
                    }, 1000);
                }

                setSpecialCooldown(3); // Reset cooldown
                setOpponentHealth(newHealth);
                addToLog(`ðŸ’« Special Attack dealt ${specialDamage} massive damage!`);
                setIsPlayerTurn(false);

                if (newHealth <= 0) {
                    await handleVictory();
                    setIsBattleOver(true);
                }
            };

            // Add cooldown effect
            React.useEffect(() => {
                if (isPlayerTurn && specialCooldown > 0) {
                    setSpecialCooldown(prev => prev - 1);
                }
            }, [isPlayerTurn]);

            // Update XP progress calculation
            const calculateXPProgress = (currentExp, level) => {
                const currentLevelTotalXP = monsterStats.calculateTotalXPToLevel(level);
                const nextLevelTotalXP = currentLevelTotalXP + monsterStats.calculateXPForNextLevel(level);
                const progress = ((currentExp - currentLevelTotalXP) / (nextLevelTotalXP - currentLevelTotalXP)) * 100;
                return Math.min(100, Math.max(0, progress));
            };

            // Add memoized monster data
            const memoizedPlayerMonster = React.useMemo(() => playerMonster, [
                playerMonster?.id,
                playerMonster?.imageUrl,
                playerMonster?.level,
                playerMonster?.HP,
                playerMonster?.AP,
                playerMonster?.Speed
            ]);

            const memoizedOpponentMonster = React.useMemo(() => ({
                ...opponentMonster,
                imageUrl: aiImageUrl
            }), [
                opponentMonster?.level,
                aiImageUrl,
                opponentMonster?.HP,
                opponentMonster?.AP,
                opponentMonster?.Speed
            ]);

            // Add these at the top of BattleSystem component
            const stablePlayerMonster = React.useRef(null);
            const stableOpponentMonster = React.useRef(null);

            // Add this effect after your existing useEffects
            React.useEffect(() => {
                if (playerMonster && !stablePlayerMonster.current) {
                    stablePlayerMonster.current = playerMonster;
                }
                if (!stableOpponentMonster.current) {
                    stableOpponentMonster.current = {
                        ...opponentMonster,
                        imageUrl: aiImageUrl
                    };
                }
            }, [playerMonster, opponentMonster, aiImageUrl]);

            // Add this function to apply health bar VFX
            const applyHealthBarVFX = (isPlayer) => {
                const healthBar = isPlayer 
                    ? document.querySelector('.health-fill.player-health') 
                    : document.querySelector('.health-fill.opponent-health');
                if (!healthBar) return;
              
                // Add VFX class then remove it after animation
                healthBar.classList.remove(isPlayer ? 'player-health-flash' : 'opponent-health-flash');
                void healthBar.offsetWidth; // reflow to restart animation
                healthBar.classList.add(isPlayer ? 'player-health-flash' : 'opponent-health-flash');
            };

            // Encouraging victory , level up and defeat messages
            const victoryMessages = [
                "Great win, {username}! ",
                "Awesome job, {username}! ",
                "Well done, {username}! ",
                "Nice work, {username}! ",
                "You did it, {username}! "  
            ];

            const levelUpMessages = [
                "Level up! {monsterName} is now level {level}!",
                "Congrats! {monsterName} reached level {level}!",
                "Amazing! {monsterName} is now level {level}!",
                "Great stuff! {monsterName} is now level {level}!",
                "Fantastic! {monsterName} hit level {level}!"
            ];

            const defeatMessages = [
                "Tough luck, {username}! Try again!",
                "Train your monsters, {username}! You'll win next time!",
                "Almost, {username}! Keep going!",
                "Close one, {username}! Don't give up!",
                "Not this time, {username}! Keep trying!",
                "You'll get it, {username}! Stay strong!"
            ];

            // Update the return JSX
            return (
                <div className="battle-container">
                    <h2>{username} vs AI Opponent</h2>
                    
                    <div className="monster">
                        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                            <div className="monster-name" style={{ marginBottom: '0.5rem', fontSize: '1.1rem' }}>
                                {activeMonster.monsterName}
                            </div>
                            <MonsterImage monster={stablePlayerMonster.current || playerMonster} />
                        </div>
                        <div className="monster-info">
                            <ul>
                                <li>Type: {activeMonster.type}</li>
                                <li>Level: {activeMonster.level}</li>
                                <li>HP: {playerHealth}/{activeMonster.HP}</li>
                                <li>AP: {activeMonster.AP}</li>
                                <li>Speed: {activeMonster.Speed}</li>
                                <li className="xp-text">
                                    XP: {(() => {
                                        try {
                                            if (!activeMonster?.experience) return '0/' + monsterStats.calculateXPForNextLevel(1);
                                            
                                            const xpInfo = monsterStats.getXPInfo(activeMonster);
                                            return `${xpInfo.currentLevelXP}/${xpInfo.nextLevelXP}`;
                                            
                                        } catch (e) {
                                            console.error('XP display error:', e);
                                            return '0/150';
                                        }
                                    })()}
                                </li>
                            </ul>
                            <div className="xp-progress">
                                <div 
                                    className="xp-progress-bar" 
                                    style={{ width: `${(() => {
                                        try {
                                            const xpInfo = monsterStats.getXPInfo(activeMonster);
                                            return xpInfo.progress;
                                        } catch (e) {
                                            console.error('Progress calculation error:', e);
                                            return 0;
                                        }
                                    })()}%` }}
                                ></div>
                            </div>
                        </div>
                    </div>
                    <div className="health-bar">
                        <div 
                            className="health-fill player-health" 
                            style={{ width: `${(playerHealth / activeMonster.HP) * 100}%` }}
                        ></div>
                    </div>

                    <div className="monster">
                        <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                            <div className="monster-name" style={{ marginBottom: '0.5rem', fontSize: '1.1rem' }}>
                                Level {opponentMonster.level} Robot
                            </div>
                            <MonsterImage monster={stableOpponentMonster.current || opponentMonster} isAI={true} />
                        </div>
                        <div className="monster-info">
                            <ul>
                                <li>Type: {opponentMonster.type}</li>
                                <li>Level: {opponentMonster.level}</li>
                                <li>HP: {opponentHealth}/{opponentMonster.HP}</li>
                                <li>AP: {opponentMonster.AP}</li>
                                <li>Speed: {opponentMonster.Speed}</li>
                            </ul>
                        </div>
                    </div>
                    <div className="health-bar">
                        <div 
                            className="health-fill opponent-health" 
                            style={{ width: `${(opponentHealth / opponentMonster.HP) * 100}%` }}
                        ></div>
                    </div>

                    <div className="battle-log">
                        <ul>
                            {battleLog.map((entry, index) => (
                                <li 
                                    key={Date.now() + index}
                                    className={
                                        entry.includes('Victory!') ? 'victory-message' : 
                                        entry.includes('Defeat!') ? 'defeat-message' : ''
                                    }
                                >
                                    {entry}
                                </li>
                            ))}
                        </ul>
                    </div>

                    <div className={`battle-controls ${!isPlayerTurn ? 'opponent-turn' : ''}`}>
                        <div>
                            {!isBattleOver ? (
                                <div>
                                    <button 
                                        onClick={handleAttack} 
                                        disabled={!isPlayerTurn || battleState !== 'ongoing'}
                                    >
                                        Attack
                                    </button>
                                    <button 
                                        onClick={handleDefend} 
                                        disabled={!isPlayerTurn || battleState !== 'ongoing'}
                                    >
                                        Defend
                                    </button>
                                    <button 
                                        onClick={handleHeal} 
                                        disabled={!isPlayerTurn || battleState !== 'ongoing'}
                                    >
                                        Heal
                                    </button>
                                    <button 
                                        onClick={handleSpecialAttack} 
                                        disabled={!isPlayerTurn || battleState !== 'ongoing' || specialCooldown > 0}
                                        style={{
                                            background: specialCooldown > 0 ? 
                                                'linear-gradient(135deg, #666, #999)' : 
                                                'linear-gradient(135deg, #c0392b, #e74c3c)',
                                            position: 'relative'
                                        }}
                                    >
                                        Special {specialCooldown > 0 ? `(${specialCooldown})` : ''}
                                    </button>
                                </div>
                            ) : (
                                <div>
                                    <button 
                                        className="nav-button start-new-battle" 
                                        onClick={() => window.location.reload()}
                                    >
                                        Start New Battle
                                    </button>
                                    <button 
                                        className="nav-button" 
                                        onClick={() => window.location.href='monster-collection.html'}
                                    >
                                        Return to Collection
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function startBattle() {
            // Hide the preview
            document.getElementById('battlePreview').style.display = 'none';
            // Hide the back to profile button
            document.querySelector('.navigation-grid').style.display = 'none';
            // Render the battle system
            ReactDOM.render(<BattleSystem />, document.getElementById('root'));
        }

        // Add this function before updatePreview
        async function fetchMonsterData(monsterId) {
            try {
                const monsterRef = db.collection('monsters').doc(monsterId);
                const doc = await monsterRef.get();
                if (doc.exists) {
                    // Include the document ID in the returned data
                    return {
                        id: doc.id,  // Add this line to preserve the ID
                        ...doc.data()
                    };
                }
                console.log('No monster document found');
                return null;
            } catch (error) {
                console.error('Error fetching monster data:', error);
                return null;
            }
        }

        // Update the updatePreview function
        async function updatePreview() {
            const urlParams = new URLSearchParams(window.location.search);
            const monsterId = urlParams.get('id');
            
            if (monsterId) {
                try {
                    // Fetch complete monster data from Firestore
                    const monsterData = await fetchMonsterData(monsterId);
                    if (!monsterData) {
                        console.error('Failed to fetch monster data');
                        return;
                    }

                    console.log('Fetched monster data:', monsterData); // Debug log

                    const playerLevel = parseInt(monsterData.level) || 1;
                    const aiLevel = calculateAILevel(playerLevel);
                    sessionStorage.setItem('aiOpponentLevel', aiLevel);

                    // Update monster name
                    const nameElement = document.getElementById('playerMonsterName');
                    if (nameElement) {
                        nameElement.textContent = monsterData.monsterName || 'Your Monster';
                    }

                    // Update monster image with imageUrl from Firestore
                    const imageContainer = document.getElementById('playerMonsterImage');
                    if (imageContainer) {
                        console.log('Setting monster image with URL:', monsterData.imageUrl); // Debug log
                        imageContainer.innerHTML = getMonsterImageHTML({
                            ...monsterData,
                            imageUrl: monsterData.imageUrl // Ensure imageUrl is included
                        });
                    }

                    // Update monster stats
                    const statsElement = document.getElementById('playerMonsterStats');
                    if (statsElement) {
                        const stats = [
                            `Level ${monsterData.level || '1'}`,
                            monsterData.type || 'Unknown',
                            `HP: ${monsterData.HP || '100'}`,
                            `AP: ${monsterData.AP || '10'}`,
                            `Speed: ${monsterData.Speed || '10'}`
                        ];
                        statsElement.textContent = stats.join(' | ');
                    }

                    // Update AI opponent preview
                    const aiPreviewElement = document.querySelector('.monster-preview:last-child p');
                    if (aiPreviewElement) {
                        const aiStats = [
                            `Level ${aiLevel}`,
                            'Type: Robot',
                            `HP: ${Math.round(20 * (1 + (aiLevel - 1) * 0.40))}`, // Updated values
                            `AP: ${Math.round(5 * (1 + (aiLevel - 1) * 0.20))}`,  // Updated values
                            `Speed: ${Math.round(5 * (1 + (aiLevel - 1) * 0.15))}` // Updated values
                        ];
                        aiPreviewElement.textContent = aiStats.join(' | ');
                    }

                    const aiNameElement = document.querySelector('.monster-preview:last-child h3');
                    if (aiNameElement) {
                        aiNameElement.textContent = `AI Monster (Lvl ${aiLevel})`;
                    }

                    // Add AI opponent image to preview
                    const aiImageUrl = await getRandomAIOpponentImage();
                    const aiPreviewImage = document.querySelector('.monster-preview:last-child .monster-image-placeholder');
                    if (aiPreviewImage && aiImageUrl) {
                        aiPreviewImage.outerHTML = `
                            <div class="monster-image-container">
                                <img 
                                    src="${aiImageUrl}"
                                    alt="AI Opponent"
                                    onerror='this.onerror=null;this.parentElement.innerHTML="<div class=\\"monster-image-placeholder\\"></div>"'
                                />
                            </div>`;
                    }
                } catch (error) {
                    console.error('Error in updatePreview:', error);
                }
            }
        }

        // Call updatePreview when page loads
        window.addEventListener('load', updatePreview);

        // Dark mode toggle
        const darkModeToggle = document.getElementById("darkModeToggle");
        const savedTheme = localStorage.getItem("theme");
        
        if (savedTheme === "dark") {
            document.body.classList.add("dark-mode");
        }

        darkModeToggle.addEventListener("click", function() {
            document.body.classList.toggle("dark-mode");
            localStorage.setItem("theme", document.body.classList.contains("dark-mode") ? "dark" : "light");
        });

        // Clean up event listeners
        window.addEventListener('load', () => {
            updatePreview();
            return () => {
                // Remove event listeners
                darkModeToggle.removeEventListener('click');
            };
        });
    </script>
</body>
</html>
